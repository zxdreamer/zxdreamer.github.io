<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dreamer</title>
  
  <subtitle>莫厌追欢笑语频，寻思离乱好伤神。闲来屈指从头数，得见清平有几人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-03T00:59:02.462Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>梦的蓝天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++查漏补缺</title>
    <link href="http://yoursite.com/2019/04/03/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>http://yoursite.com/2019/04/03/C-查漏补缺/</id>
    <published>2019-04-03T00:44:16.000Z</published>
    <updated>2019-04-03T00:59:02.462Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录使用C++的过程中的不足和tips<br><a id="more"></a><br>C语言知识盲点<br>一、c register and static用法<br>    1、register变量将被频繁调用，请求编译器尽可能存在cpu中，而不是内存中<br>        注意：<br>        register变量必须是被cpu寄存器接受的值。<br>        register变量不能用取地址符&amp;<br>        只有局部变量和形参可以用static，全局变量和静态变量不可以<br>    2、static关键字的作用<br>        首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0</p><p>二、#define的高级用法——定义复杂函数,只是没有{}，语句结尾没有分号<br>    用#define和连接符可以定义复杂函数<br>    比如：</p><pre><code>#define swap(a.b) do{\    int t = 0;\    t=a;\    a=b;\    b=t;\    }while(0)</code></pre><p>三、虚函数表<br>    1、虚函数表是在对象被创建的时候生成的，每一个对象对应一张虚函数表<br>    2、虚函数表中存有对象的所有函数，包括从基类继承的，没有被派生类覆盖的<br>    3、键关系图<br>    至少包含一个纯虚函数的类是抽象类，抽象类不能实例化对象。<br>    接口中不予许含有成员变量，但可以含有静态变量，不可以有构造函数，但一定要有纯虚析构函数<br>    虚函数就可以执行动态绑定。纯虚函数是在虚函数的末尾加入=0;<br>    <img src="/2019/04/03/C-查漏补缺/虚函数表.png" alt="虚函数表"><br>四、#undefined 临时关闭一个#define的宏<br>五、指针数组与指向指针的数组，引出指针运算的结合顺序：<br>        在无括号时，从右向左解释；有括号时，先解释括号中的内容，然后再说明按照从右向左的顺序解释<br>        typedef int Patharc[10];<br>        void shortPath(MGrath g,Patharc <em>p)<br>        形参的类型：int (</em>p)[10],说明p是一个指向数组的指针<br>        特别注意的一点是：行指针与指针数组都需要先申请内存才能用。<br>六、深拷贝和浅拷贝主要针对指针来说，对于存在指针变量的对象，执行浅拷贝时没有分离两个对象的关联。此时需要自定义深拷贝构造函数<br>     原则是：对于值类型直接赋值，指针类型要重新分配内存空间。<br>     拷贝构造函数形式：类名(类名 &amp;,…)<br>七、C++使用默认参数<br>    1、在声明中指定默认参数，在定义时要省略这个参数<br>    2、若不声明，可以在定义中直接指定默认参数<br>    double sqrt(double f = 1.0); //函数声明</p><pre><code>double sqrt(double f)  //函数定义{  // ....  }</code></pre><p>八、函数指针作为形参有两种形式<br>    1、直接在形参的位置声明一个函数指针—void Mysort(vector<int> v,bool (*cmp)(const int a,const int b))<br>    2、使用typedef定义一种函数指针新类型，然后在形参处使用这种类型定义的变量相当于函数指针了。<br>九、c register and static用法<br>    1、register变量将被频繁调用，请求编译器尽可能存在cpu中，而不是内存中<br>        注意：<br>        register变量必须是被cpu寄存器接受的值。<br>        register变量不能用取地址符&amp;<br>        只有局部变量和形参可以用static，全局变量和静态变量不可以<br>    2、static关键字的作用<br>        首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0<br>十、#define的高级用法——定义复杂函数,只是没有{}，语句结尾没有分号<br>    用#define和连接符可以定义复杂函数<br>    比如：</int></p><pre><code>#define swap(a.b) do{\    int t = 0;\    t=a;\    a=b;\    b=t;\    }while(0)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录使用C++的过程中的不足和tips&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="template,alogorithm,class,API" scheme="http://yoursite.com/tags/template-alogorithm-class-API/"/>
    
  </entry>
  
  <entry>
    <title>python笔记</title>
    <link href="http://yoursite.com/2019/04/02/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/02/python笔记/</id>
    <published>2019-04-02T05:16:00.000Z</published>
    <updated>2019-04-02T05:50:15.006Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记<br><a id="more"></a></p><p>一、dict使用<br>    1、创建{}<br>    2、使用dict()将含有双值子序列的序列转化成字典<br>    3、使用update()合并两个字典，若有重复则替换<br>    4、使用del删除指定key的字典<br>    5、使用clear()或指向一个{}清空dict<br>    6、使用in判断键值是否在字典中<br>    7、使用keys()获取所有键。使用values获取所有值<br>    8、使用items获取所有键值对，每一个键值对用tuple形式存储，整体用list存储<br>二、tuple使用<br>    1、创建， </p><p>三、函数<br>    1、yield 创建迭代器函数使用的关键字，每一次迭代遇到yield就返回其后的值，下一次迭代从此处(函数处)开始。<br>        def my_range(first=0,last=5,step=1):<br>            number = first<br>            while number &lt; last:<br>                yield number<br>                number += step</p><p>四、类<br>    1、self 指向这个被创建的对象本身<br>    2、对象调用成员函数做的两件事：<br>        a、找到对象所属的类<br>        b、将对象传递给成员函数的self参数<br>    3、super()方法<br>    4、属性 name=property(get,set)<br>    5、名称重整：<strong>name<br>    6、@classmethod 类方法，@staticmethod 静态方法<br>    7、iterator和iteratable：重要的两个方法：</strong>iter__()：返回迭代器本身<br>                                             <strong>next</strong>():返回当前值<br>                                                       :改变iterator状态<br>    8、generator 只要包含<strong>iter</strong>()和<strong>next</strong>()即可，但直接用yield也可以。有两种使用方式：next()和send()<br>    9、特殊方法，其实就是运算符重载<br>五、@abstractmethod方法<br>    python中的接口必须借助ABC模块使用–from abc import AECMeta,abstarctmethod<br>    @abstractmethod<br>    def 方法名():</p><pre><code>@abstractmethod方法必须被子类重载。带@abstractmethod的方法不能实例化        </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="generator,class" scheme="http://yoursite.com/tags/generator-class/"/>
    
  </entry>
  
  <entry>
    <title>vim学习笔记(一)</title>
    <link href="http://yoursite.com/2019/04/02/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/04/02/vim学习笔记一/</id>
    <published>2019-04-02T02:31:56.000Z</published>
    <updated>2019-04-02T05:36:45.067Z</updated>
    
    <content type="html"><![CDATA[<p>常用vim指令<br><a id="more"></a><br>撤销：u<br>复制和粘贴：在退出编辑后。v+移动光标+y(复制)+p(粘贴)  –yump(复制)，put(放置)<br>批量缩进：  在退出编辑后。:24,26&gt;  –右移，:24,26&lt; –左移<br>修改指令别名：<br>    以下是一种改完之后永久生效的方法<br>    1、在用户的家目录找到.bashrc,vim ~/.bashrc<br>    2、在.bashrc中添加修改别名语句：alias wmysql=’mysql -u root -pxidianicelab313’，保存退出<br>    3、在终端使.bashrc生效（不用重启）：source ~/.bashrc</p><p>备注：source指令：使当前shell读入文件路径并以此执行文件中的指令，用于执行刚修改的初始化文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用vim指令&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux指令" scheme="http://yoursite.com/categories/linux%E6%8C%87%E4%BB%A4/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
