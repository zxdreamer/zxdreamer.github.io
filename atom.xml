<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dreamer</title>
  
  <subtitle>莫厌追欢笑语频，寻思离乱好伤神。闲来屈指从头数，得见清平有几人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-30T02:05:54.040Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>梦的蓝天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/08/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/30/单例模式/</id>
    <published>2019-08-30T02:05:15.000Z</published>
    <updated>2019-08-30T02:05:54.040Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tank</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~tank();</span><br><span class="line"><span class="function"><span class="keyword">static</span> tank* <span class="title">getObj</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">tank()</span><br><span class="line">&#123;</span><br><span class="line">g_id = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">tank(<span class="keyword">const</span> tank&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">tank&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> tank&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> tank *obj;</span><br><span class="line"><span class="keyword">int</span> g_id;</span><br><span class="line"><span class="keyword">static</span> mutex mx;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tank.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">tank::~tank()</span><br><span class="line">&#123;</span><br><span class="line">g_id--;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~tank"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tank::getID()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ++g_id;</span><br><span class="line">&#125;</span><br><span class="line">tank* tank::getObj()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">mx.lock();</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">obj = <span class="keyword">new</span> tank();</span><br><span class="line">mx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员初始化一次</span></span><br><span class="line">tank* tank::obj = <span class="literal">NULL</span>;</span><br><span class="line">mutex tank::mx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tank *t1=tank::getObj();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t1-&gt;getID() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">tank *t2 = tank::getObj();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t2-&gt;getID() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2019/08/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/30/排序算法/</id>
    <published>2019-08-30T01:57:51.000Z</published>
    <updated>2019-08-30T02:00:09.314Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort2(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag == <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=L-&gt;length<span class="number">-2</span>;j&gt;=i;j--)</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[j] &gt; L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(L,j,j+<span class="number">1</span>);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,key;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;r[i] &lt; L-&gt;r[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            key = L-&gt;r[i];        <span class="comment">//set watcher to permit j to lower then 0</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>;j &gt;= <span class="number">0</span> &amp;&amp; L-&gt;r[j]&gt;key;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                L-&gt;r[j+<span class="number">1</span>] = L-&gt;r[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="number">0</span>)</span><br><span class="line">                L-&gt;r[<span class="number">0</span>] = key;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L-&gt;r[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void SelectSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,min;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>;j&lt;L-&gt;length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[min] &gt; L-&gt;r[j])   <span class="comment">//sort</span></span><br><span class="line">                min = j;</span><br><span class="line">           <span class="comment">// if(L-&gt;r[min] &lt; L-&gt;r[j])   //desc sort</span></span><br><span class="line">           <span class="comment">//     min = j;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i)</span><br><span class="line">            swap(L,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShellSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,gap;</span><br><span class="line">    gap = L-&gt;length;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        gap = gap/<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = gap + <span class="number">1</span>;i&lt;=L-&gt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[i] &lt; L-&gt;r[i-gap])</span><br><span class="line">            &#123;</span><br><span class="line">                L-&gt;r[<span class="number">0</span>] = L-&gt;r[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i-gap;j&gt;<span class="number">0</span> &amp;&amp; L-&gt;r[j] &gt; L-&gt;r[<span class="number">0</span>];j-=gap)</span><br><span class="line">                L-&gt;r[j+gap] = L-&gt;r[j];</span><br><span class="line"></span><br><span class="line">                L-&gt;r[j+gap] = L-&gt;r[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(gap &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapAdjest(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> temp = L-&gt;r[s];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>*s;i &lt;= m;i *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m &amp;&amp; L-&gt;r[i] &lt; L-&gt;r[i+<span class="number">1</span>])</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= L-&gt;r[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        L-&gt;r[s] = L-&gt;r[i];</span><br><span class="line">        s=i;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[s] = temp;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(SqList *L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;length/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        HeapAdjest(L,i,L-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(L,<span class="number">1</span>,i);</span><br><span class="line">        HeapAdjest(L,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Partition3(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotkey;</span><br><span class="line">    <span class="keyword">int</span> m = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;r[low] &gt; L-&gt;r[high])</span><br><span class="line">        swap(L,low,high);</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;r[m] &gt; L-&gt;r[high])</span><br><span class="line">        swap(L,m,high);</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;r[m] &gt; L-&gt;r[low])</span><br><span class="line">        swap(L,low,m);</span><br><span class="line">    pivotkey = L-&gt;r[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L-&gt;r[high] &gt; pivotkey)</span><br><span class="line">            high--;</span><br><span class="line">        swap(L,low,high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L-&gt;r[low] &lt; pivotkey)</span><br><span class="line">            low++;</span><br><span class="line">        swap(L,low,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight zephir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://yoursite.com/2019/08/30/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>http://yoursite.com/2019/08/30/字典树/</id>
    <published>2019-08-30T00:56:42.000Z</published>
    <updated>2019-08-30T00:57:54.797Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典树边作为存储字母，节点表示从根节点到此节点路径上的所有字母。所以叶子节点存储全部单词。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 26</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>[<span class="title">Max</span>];</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//创建一个新节点</span></span><br><span class="line"><span class="function">Node *<span class="title">createNew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Max;i++)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_str</span><span class="params">(<span class="keyword">char</span> str[], Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">Node *t, *p = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next[c] == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = createNew();</span><br><span class="line">p-&gt;next[c] = t;</span><br><span class="line">p-&gt;num++;</span><br><span class="line"><span class="comment">//cout&lt;&lt;p-&gt;num&lt;&lt;endl;</span></span><br><span class="line">p = p-&gt;next[c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next[c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_str</span><span class="params">(<span class="keyword">char</span> str[], Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = head;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c = str[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next[c] == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"不存在字符串"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next[c];</span><br><span class="line">count = p-&gt;num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"nihao"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Node *head = createNew();</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s, <span class="built_in">strcmp</span>(s, <span class="string">"quit"</span>))</span><br><span class="line">&#123;</span><br><span class="line">Insert_str(s, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c = Search_str(<span class="string">"abc"</span>, head);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树非递归遍历</title>
    <link href="http://yoursite.com/2019/08/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/08/30/二叉树非递归遍历/</id>
    <published>2019-08-29T16:12:44.000Z</published>
    <updated>2019-08-30T01:51:08.578Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTranverse</span><span class="params">(Tree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;Tree*&gt; skTree;</span><br><span class="line">skTree.push_back(root);</span><br><span class="line"><span class="built_in">vector</span>&lt;Tree*&gt; vTree;</span><br><span class="line"><span class="keyword">while</span>(skTree.size() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Tree* tmp = skTree.top();</span><br><span class="line">vTree.push_back(tmp);</span><br><span class="line"><span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">skTree.push_back(tmp-&gt;right);</span><br><span class="line"><span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">skTree.push_back(tmp-&gt;left);</span><br><span class="line"></span><br><span class="line">skTree.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTransverse</span><span class="params">(Tree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">statck&lt;Tree*&gt; skTree;</span><br><span class="line">skTree.push_back(root);</span><br><span class="line"><span class="built_in">vector</span>&lt;Tree*&gt; vTree;</span><br><span class="line"><span class="keyword">while</span>(skTree.size() &gt; <span class="number">0</span> || head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">skTree.push(head);</span><br><span class="line">head = head-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Tree* tmp = skTree.top();</span><br><span class="line">vTree.push_back(tmp);</span><br><span class="line">head = head-&gt;right;</span><br><span class="line">skTree.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backOrderTransverse</span><span class="params">(Tree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;Tree*&gt; skTree;</span><br><span class="line"><span class="built_in">stack</span>&lt;Tree*&gt; resTree;</span><br><span class="line"><span class="built_in">vector</span>&lt;Tree*&gt; vTree;</span><br><span class="line">skTree.push(root);</span><br><span class="line"><span class="keyword">while</span>(skTree.size() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Tree* tmp = skTree.top();</span><br><span class="line">resTree.push(tmp);</span><br><span class="line">skTree.pop();</span><br><span class="line"><span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">skTree.push(tmp-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">skTree.push(tmp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(resTree.size() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Tree* resTmp = resTree.top();</span><br><span class="line">vTree.push(resTmp);</span><br><span class="line">resTree.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排列组合</title>
    <link href="http://yoursite.com/2019/08/30/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2019/08/30/排列组合/</id>
    <published>2019-08-29T16:11:06.000Z</published>
    <updated>2019-08-29T16:11:45.857Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">一、全排列</span><br><span class="line"><span class="comment">//这里的一个难点在于vecPermutated不用清零。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecPermutated, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecWaitPermuta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWaitPermuta.size() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itNum = vecWaitPermuta.begin();itNum != vecWaitPermuta.end();++itNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecPermutatedTmp = vecPermutated;</span><br><span class="line">vecPermutatedTmp.push_back(*itNum);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecWaitPermutaTmp = vecWaitPermuta;</span><br><span class="line"><span class="comment">//删除当前已经加入排列完毕的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator retFind = find(vecWaitPermutaTmp.begin(), vecWaitPermutaTmp.end(), *itNum);</span><br><span class="line"><span class="keyword">if</span> (vecWaitPermutaTmp.end() != retFind)</span><br><span class="line">&#123;</span><br><span class="line">vecWaitPermutaTmp.erase(retFind);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续递归调用排列算法</span></span><br><span class="line">Permutation(vecPermutatedTmp, vecWaitPermutaTmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//一组排列完毕</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印排列结果</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecPermutated.size();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; vecPermutated.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">二、组合问题</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">( <span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ,  <span class="keyword">int</span> b[], <span class="keyword">const</span> <span class="keyword">int</span> M )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=m; i--)   <span class="comment">// 注意这里的循环范围</span></span><br><span class="line">&#123;</span><br><span class="line">b[m<span class="number">-1</span>] = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (m &gt; <span class="number">1</span>)</span><br><span class="line">combine(a,i<span class="number">-1</span>,m<span class="number">-1</span>,b,M);</span><br><span class="line"><span class="keyword">else</span>                     <span class="comment">// m == 1, 输出一个组合</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=M<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[b[j]] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">a[i] = i+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 递归方法</span></span><br><span class="line"><span class="keyword">int</span> b[M];</span><br><span class="line">combine(a,N,M,b,M);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2019/08/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2019/08/30/并查集/</id>
    <published>2019-08-29T16:08:28.000Z</published>
    <updated>2019-08-29T16:10:33.573Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>题目背景：<br>有n个地点，m条路<br>给出现有路径，求在修多少路可以是n个地点互通。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//4 2 4个点，2条路</span></span><br><span class="line"><span class="comment">//1 3 4 3</span></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//查找掌门同时路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = x;</span><br><span class="line"><span class="keyword">while</span> (pre[r] != r)  <span class="comment">//直到找到掌门为止，无路径压缩</span></span><br><span class="line">r = pre[r];      </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = x; <span class="keyword">int</span> j;    <span class="comment">//路径压缩</span></span><br><span class="line"><span class="keyword">while</span> (i != r)</span><br><span class="line">&#123;</span><br><span class="line">j = pre[i];      <span class="comment">//i的上级  </span></span><br><span class="line">pre[i] = r;      <span class="comment">//指向大掌门</span></span><br><span class="line">i = j;           <span class="comment">//记下i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>   <span class="comment">//掌门人之间连接起来</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx = find(x);</span><br><span class="line"><span class="keyword">int</span> fy = find(y);</span><br><span class="line"><span class="keyword">if</span> (fx != fy)</span><br><span class="line">&#123;</span><br><span class="line">pre[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k,m, p1, p2, i, total, f1, f2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt;m;          <span class="comment">//读入n个位置，m条路                                                         //刚开始的时候，有n个城镇，一条路都没有 //那么要修n-1条路才能把它们连起来</span></span><br><span class="line"></span><br><span class="line">total = n - <span class="number">1</span>;         <span class="comment">//连接n个顶点，使用n-1条路</span></span><br><span class="line"><span class="comment">//每个点互相独立，自成一个集合，从1编号到n，所以每个点的上级都是自己</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;= n;i++) &#123; pre[i] = i; &#125;                <span class="comment">//共有m条路</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;    <span class="comment">//下面这段代码，其实就是join函数，只是稍作改动以适应题目要求</span></span><br><span class="line"> <span class="comment">//每读入一条路，看它的端点p1，p2是否已经在一个连通分支里了</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">f1 = find(p1);</span><br><span class="line">f2 = find(p2);</span><br><span class="line"><span class="comment">//如果是不连通的，那么把这两个分支连起来</span></span><br><span class="line"><span class="comment">//分支的总数就减少了1，还需建的路也就减了1</span></span><br><span class="line"><span class="keyword">if</span> (f1 != f2)</span><br><span class="line">&#123;</span><br><span class="line">pre[f2] = f1;</span><br><span class="line">total--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果两点已经连通了，那么这条路只是在图上增加了一个环 //对连通性没有任何影响，无视掉</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后输出还要修的路条数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k-total);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;题目背景：&lt;br&gt;有n个地点，m条路&lt;br&gt;给出现有路径，求在修多少路可以是n个地点互通。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>宏函数linux版</title>
    <link href="http://yoursite.com/2019/08/30/%E5%AE%8F%E5%87%BD%E6%95%B0linux%E7%89%88/"/>
    <id>http://yoursite.com/2019/08/30/宏函数linux版/</id>
    <published>2019-08-29T16:00:22.000Z</published>
    <updated>2019-08-29T16:01:47.043Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个例子展示了怎样在宏中定义变量，怎样使用if-else，怎样返回值。</span></span><br><span class="line"><span class="comment">//int tmp = 5; 定义一个int型的变量，在结尾要加;</span></span><br><span class="line"><span class="comment">//if-else      可以按照c语言一样使用if-else，for，while等</span></span><br><span class="line"><span class="comment">//(addr+tmp) ; 宏函数的最后一句就是返回值</span></span><br><span class="line"><span class="comment">//(&#123;...&#125;)      宏函数有返回值时要用()将宏包起来</span></span><br><span class="line"><span class="comment">//  \          \ 代表将多行转化成一行输出，预编译时完成转化。宏定义需要写成一行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KADDR(addr)(&#123; \</span></span><br><span class="line">    <span class="keyword">int</span> tmp = addr;   \</span><br><span class="line">    <span class="keyword">if</span>(addr&gt;<span class="number">5</span>)  \</span><br><span class="line">        tmp=<span class="number">2</span>;  \</span><br><span class="line">    <span class="keyword">else</span>        \</span><br><span class="line">        tmp = <span class="number">3</span>;\</span><br><span class="line">    (addr + tmp);\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是昨天的四个问题，你的思路也是对的，接下来按照你的思路练习一下。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_DOWN(a,b) &#123; \</span></span><br><span class="line">    (a)-(a)%(b)\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_UP(a,b) &#123;\</span></span><br><span class="line">    (a)+(b)-(a)%(b)\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_2N_DOWN(a,b) (&#123;   \</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;  \</span><br><span class="line">    <span class="keyword">do</span>&#123;     \</span><br><span class="line">        b = b&gt;&gt;<span class="number">1</span>;     \</span><br><span class="line">        c += (b)&amp;a;   \</span><br><span class="line">    &#125;<span class="keyword">while</span>(b!=<span class="number">0</span>);     \</span><br><span class="line">    c = a-c;          \</span><br><span class="line">    c;                \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN_2N_UP(a,b) (&#123; \</span></span><br><span class="line">    <span class="keyword">int</span> _b = (b);       \</span><br><span class="line">    ((_b) + ALIGN_2N_DOWN(a,b));\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> g = KADDR(addr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;g&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">65</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = ALIGN_DOWN(<span class="number">65</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> d = ALIGN_UP(<span class="number">65</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> e = ALIGN_2N_DOWN(a, b);</span><br><span class="line">    a = <span class="number">65</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> f = ALIGN_2N_UP(a,b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
    
      <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>DFS与BFS</title>
    <link href="http://yoursite.com/2019/08/29/DFS%E4%B8%8EBFS/"/>
    <id>http://yoursite.com/2019/08/29/DFS与BFS/</id>
    <published>2019-08-29T15:57:22.000Z</published>
    <updated>2019-08-30T01:13:00.001Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 4</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXVEX] = &#123; <span class="literal">false</span>, <span class="literal">false</span> ,<span class="literal">false</span> ,<span class="literal">false</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(MAXVEX);</span><br><span class="line"><span class="comment">//有向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">adj[v].push_back(w);   <span class="comment">//将顶点w加到v的链表上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无向图</span></span><br><span class="line"><span class="comment">//void addEdge(int v, int w)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//adj[v].push_back(w);     // 将w加到v的list </span></span><br><span class="line"><span class="comment">//adj[w].push_back(v);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//单个连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> vx = v;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">visited[vx] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">queue</span>.push_back(vx);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty())</span><br><span class="line">&#123;</span><br><span class="line">vx = <span class="built_in">queue</span>.front();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; vx &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">queue</span>.pop_front();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (it = adj[vx].begin();it != adj[vx].end();it++)  <span class="comment">//扫描链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[*it])</span><br><span class="line">&#123;</span><br><span class="line">visited[*it] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">queue</span>.push_back(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MutilBFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAXVEX;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i])</span><br><span class="line">&#123;</span><br><span class="line">bfs(i);  <span class="comment">//多个连通分量调用多次BFS，从0个分量开始遍历</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visited[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = adj[v].begin();it != adj[v].end();++it)  <span class="comment">//遍历一个节点然后到下一个节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[*it])</span><br><span class="line">dfs(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">addEdge(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">addEdge(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">bfs(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//dfs(2);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="http://yoursite.com/2019/08/29/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/29/查找算法/</id>
    <published>2019-08-29T15:54:08.000Z</published>
    <updated>2019-08-29T15:54:08.220Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://yoursite.com/2019/08/29/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2019/08/29/智能指针/</id>
    <published>2019-08-29T15:41:11.000Z</published>
    <updated>2019-08-30T01:40:14.547Z</updated>
    
    <content type="html"><![CDATA[<p>智能指针<br>    1、智能指针是利用一种RAII的技术对普通指针进行封装，其实是一个对象，行为却像一个指针。<br>    2、智能指针时防止忘记调用delete或两次delete带来的内存问题。<br>    3、将值语义转化成对象语义。<br>    4、智能指针的使用shared_ptr/weak_ptr/unique_ptr<br>        shared_ptr:多个指针指向相同的对象。使用引用计数，每次使用它，内部引用+1，每次析构，内部引用-1.为0时自动释放内存。陷阱是循环引用。<br>        weak_ptr:协助shared_ptr工作，不会引起weak_ptr的引用计数的加减。<br>        循环引用问题，A类引用B类的shared_ptr,B类应用A类的shared_ptr。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myshared_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra = make_shared&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra2(ptra);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>* pb = &amp;a;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptrb = make_shared&lt;<span class="keyword">int</span>&gt;(b);</span><br><span class="line">ptra2 = ptrb;</span><br><span class="line">pb = ptra.get();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myweak_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sh_ptr.use_count() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">weak_ptr&lt;<span class="keyword">int</span>&gt; wp(sh_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wp.expired())  <span class="comment">//等价use_count()==0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr2 = wp.lock();<span class="comment">//从被观测的shared_ptr中获得一个可用的shared_ptr对象</span></span><br><span class="line">*sh_ptr = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//std::shared_ptr&lt;Child&gt; ChildPtr;</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//new shared_ptr</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.lock()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Parent() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Child() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; p(<span class="keyword">new</span> Parent);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; c(<span class="keyword">new</span> Child);</span><br><span class="line">p-&gt;setChild(c);</span><br><span class="line">c-&gt;setPartent(p);</span><br><span class="line">wpp = p;</span><br><span class="line">wpc = c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpc.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;智能指针&lt;br&gt;    1、智能指针是利用一种RAII的技术对普通指针进行封装，其实是一个对象，行为却像一个指针。&lt;br&gt;    2、智能指针时防止忘记调用delete或两次delete带来的内存问题。&lt;br&gt;    3、将值语义转化成对象语义。&lt;br&gt;    4、智能指针的使用shared_ptr/weak_ptr/unique_ptr&lt;br&gt;        shared_ptr:多个指针指向相同的对象。使用引用计数，每次使用它，内部引用+1，每次析构，内部引用-1.为0时自动释放内存。陷阱是循环引用。&lt;br&gt;        weak_ptr:协助shared_ptr工作，不会引起weak_ptr的引用计数的加减。&lt;br&gt;        循环引用问题，A类引用B类的shared_ptr,B类应用A类的shared_ptr。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sed指令--高阶</title>
    <link href="http://yoursite.com/2019/05/01/sed%E6%8C%87%E4%BB%A4-%E9%AB%98%E9%98%B6/"/>
    <id>http://yoursite.com/2019/05/01/sed指令-高阶/</id>
    <published>2019-05-01T07:16:47.000Z</published>
    <updated>2019-05-01T07:33:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>讲述正则表达式，sed结合正则表达式的高阶指令</p><a id="more"></a><p>正则表达式：<br>    特殊字符:   .*[]^${}+?|()<br>    记住不能在文本中使用这些特殊字符。必须用\转义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述正则表达式，sed结合正则表达式的高阶指令&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>static成员变量的赋值</title>
    <link href="http://yoursite.com/2019/04/27/static-%E6%88%90%E5%91%98/"/>
    <id>http://yoursite.com/2019/04/27/static-成员/</id>
    <published>2019-04-27T15:52:22.000Z</published>
    <updated>2019-04-27T16:04:22.144Z</updated>
    
    <content type="html"><![CDATA[<p>讲述static成员变量的初始化与赋值</p><a id="more"></a><p>static变量在类内声明时，属于类，或者说属于所有对象，我们可以使用类或对象调用。<br>但是static变量的定义放到哪里呢？<br>&lt;&lt;c++ primer&gt;&gt;说在类外定义和初始化是保证static成员变量只被定义一次的好方法。<br>但，为什么static const int就可以在类里面初始化呢？<br>想起C中一个函数里定义一个static变量是为了保证只初始化一次。<br>那么，是否可以这样理解:<br>static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,<br>这样编译器就不必考虑类的函数里面第一个对static变量的’=’操作是赋值还是初始化了。<br>比如：<br>class A{<br>    static int a = 5;<br>    int b = 6;<br>};<br>接下来我们用对象调用a,b<br>A a1;<br>a1.a = 6;//此时a被赋值成6</p><p>A a2;   //此时编译器不知道成员a是5 还是6，就造成错误。</p><p>所以C++规定static成员变量只能在类内声明，在类外实例化。<br>比如如下操作时合理的<br>.h文件声明<br>#include “fixed_alloc.h”<br>class Foo{<br>    private:<br>        int i;<br>    public:<br>        Foo(int x):i(x){}<br>        int get(){<br>            return i;<br>        }   </p><pre><code>    static void* operator new(size_t size);    static void operator delete(void* p,size_t size);protected:    static FixedAlloc alloc;    static const int a = 5;</code></pre><p>};<br>.cpp文件中实例化<br>#include “Foo.h”<br>FixedAlloc Foo::alloc(sizeof(Foo),64);<br>void* Foo::operator new(size_t size)<br>{<br>    if(sizeof(Foo) != size)<br>        return ::operator new(size);</p><pre><code>return alloc.allocate();</code></pre><p>}<br>void Foo::operator delete(void* p,size_t size)<br>{<br>    if(p == NULL)<br>        return;<br>    if(size != sizeof(Foo))<br>    {<br>        ::operator delete(p);<br>        return;<br>    }<br>    return alloc.deallocate(p);<br>}<br>这里特别注意static结合const使用时是可以在类内初始化的，看了上面的解释就能明白为什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述static成员变量的初始化与赋值&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>ctags插件使用</title>
    <link href="http://yoursite.com/2019/04/25/ctags%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/25/ctags插件使用/</id>
    <published>2019-04-25T07:31:53.000Z</published>
    <updated>2019-04-25T08:22:40.904Z</updated>
    
    <content type="html"><![CDATA[<p>ctags插件可以实现在多个文件之间跳转，包括转到定义，转回等。</p><a id="more"></a><p>ctags的功能：扫描指定的源文件，找出其中所包含的语法元素，并将找到的相关内容记录下来。<br>ctags是怎样工作的：<br>不管一次扫描多少文件，一条ctags命令把记录的内容都记到一个文件里去，默认是当前目录的tags文件，当然这是可以更改的。<br>每个语法元素对应文件里的一行，学名叫tag entry。<br>1）             开头是tag的名字，其实也就是语法元素的名字，例如记录的是函数的话则tag名就是函数名，记录的是类的话，tag名就是类名。<br>2）             接下来是一个tab。<br>3）             接下来是语法元素所在的文件名。<br>4）             又是一个tab。<br>5）             一条“命令”。这个要解释一下意义：ctags所记录的内容的一个功能就是要帮助像vi这样的编辑器快速定位到语法元素所在的文件中去。前面已经记录了语法元素所在的文件，这条命令的功能就是一旦在vi中打开语法元素所在的文件，并且执行了该“命令”后，vi的光标就能定位到语法元素在文件中的具体位置。所以该“命令”的内容一般分两种，一种是一个正则表达式的搜索命令，一种是第几行的指向命令。默认让ctags在记录时自行选择命令的种类，选择的依据不详，可以通过命令行参数来强制ctags使用某种命令，这里就不多谈了。<br>6）             对于本tag entry（简称tag）所对应的语法元素的描述，例如语法元素的类型等。具体内容和语法元素的种类密切相关。显示哪些描述，显示的格式等都是可以在命令行指定的。例如如下命令要求描述信息中要包含：a表示如果语法元素的类的成员的话，要标明其access（即是public的还是private的）；i表示如果有继承，标明父类；K表示显示语法元素的类型的全称；S表示如果是函数，标明函数的signature；z表示在显示语法元素的类型是使用kind:type的格式。<br>ctags -R –fields=+aiKSz<br>    ctags除了记录上述的各种内容之外，还可以在tags文件中记录本次扫描的各个文件，一个文件名对应一个tag entry。默认是不记录的，要强制记录要是使用如下命令：<br>ctags –R –extra=+f<br>    还可以强制要求ctags做这样一件事情——如果某个语法元素是类的一个成员，当然ctags默认会给其记录一个tag entry（说白了就是在tags文件里写一行），可以要求ctags对同一个语法元素再记一行。举一个例子来说明：假设语法元素是一个成员函数，ctags默认记录的tag entry中的tag的名字就是该函数的名字（不包括类名作为前缀），而我们强制要求ctags多记的那个tag entry的tag的名字是包含了类明作为前缀的函数的全路径名。这样做有什么好处见下文分析。强制ctags给类的成员函数多记一行的命令为：<br>ctags -R –extra=+q。</p><p>ctrl+] : CTRL+] 命令会取当前光标下的word作为tag的名字并直接跳转。<br>        也可以，现在你在Vim中要跳到一个函数的定义(如startlist)就可以用下面的命令：<br>           (ex command) :tag startlist<br>ctrl+T : CTRL+T命令会跳到你前一次的tag处。<br>      “:tag”命令会在当前窗口中载入包含了目标函数定义的文件。但假设你不仅要查看新的函数定义。<br>      还要同时保留当前的上下文呢？你可以在”:tag”后使用一个分隔窗口命令”:split”。Vim还有一个一举两得的命令：<br>          (ex command) :stag tagname<br>ctags -R: 搜索整个目录树，然后告诉编译器你的tags在哪个文件中:set tags=~/proj/tags<br>同名tags：当一个函数被多次重载(或者几个类里都定义了一些同名的函数)，”:tag”命令会跳转到第一个符合条件的。如果当前文件中就有一个匹配的，那又会优先使用它。当然还得有办法跳转到其它符合条件的tag去：<br>          (ex command) :tnext<br>          重复使用这个命令可以发现其余的同名tag。如果实在太多，还可以用下面的命令从中直接选取一个：<br>          (ex command) :tselect tagname<br>分隔窗口:(ex command) :stag tagname<br>下面的命令可以为当前目录下的所有C程序文件生成对应的tags文件：<br>    (shell command) ctags *.c</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ctags插件可以实现在多个文件之间跳转，包括转到定义，转回等。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>ARP</title>
    <link href="http://yoursite.com/2019/04/23/ARP/"/>
    <id>http://yoursite.com/2019/04/23/ARP/</id>
    <published>2019-04-23T09:02:01.000Z</published>
    <updated>2019-04-23T09:21:46.723Z</updated>
    
    <content type="html"><![CDATA[<p>讲解地址解析协议ARP的工作原理</p><a id="more"></a><p>ARP：将32位IP地址转化成48位MAC地址。<br>每一台主机或路由器中都存在一张ARP表，记录IP地址与MAC地址的映射关系，这种映射关系是这样形成的：<br>当主机A向主机B发送数据包时，<br>先查询ARP表中是否有IP和MAC地址的缓存，如果缓存存在，则将用户数据<br>加入TCP/UDP首部，加入IP首部，加入以太网首部，其中以太网首部包含MAC地址和帧类型(IPv4,IPv6)。<br>如果主机A中不存在主机B的IP与MAC的ARP缓存，主机A发送一个ARP报文，ARP包结构如下：<br><img src="/2019/04/23/ARP/ARP.png" alt="ARP.png"><br>硬件类型（16位）：指定物理地址的类型，1表示以太网。<br>上层协议类型（16位）：指定要将MAC地址映射成什么协议的地址。0x0800表示IP地址。<br>MAC地址长度（8位）：指定MAC地址的长度，单位是字节。<br>协议地址长度（8位）：指定协议地址的长度，单位为字节。<br>操作类型：1表示ARP请求、2表示ARP回应、3表示RARP请求，4表示RARP回应。<br>接下来为发送源的物理地址和协议地址（由于回应时要知道发送给谁，以此来封装以太帧），目的物理地址和协议地址。<br>封装ARP请求时，发送源除了目的物理地址外都会填写。</p><p>ARP请求报文中存主机B的IP地址，MAC地址为FF-FF-FF-FF-FF-FF，代表广播MAC地址。子网中每一台主机收到<br>这个ARP报文后，与报文中的IP地址比较，若想等，将自己的MAC地址放入ARP应答报文中，发送给主机A，同时<br>子网中每一台设备的ARP表中存放主机Ａ的IP和MAC的映射关系。主机A收到ARP应答报文后，在原来的ARP表中追加记录。<br>并发送IP数据报。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解地址解析协议ARP的工作原理&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>STL源码-list</title>
    <link href="http://yoursite.com/2019/04/21/STL%E6%BA%90%E7%A0%81-list/"/>
    <id>http://yoursite.com/2019/04/21/STL源码-list/</id>
    <published>2019-04-21T02:50:13.000Z</published>
    <updated>2019-04-21T15:20:15.786Z</updated>
    
    <content type="html"><![CDATA[<p>list在标准库中被定义成双向链表，接下来我们重点介绍list模板类，list的迭代器<br>和解决算法与迭代器的问答关系的萃取机–iterator_traits。<br><img src="/2019/04/21/STL源码-list/list%E7%BB%93%E6%9E%84.png" alt="list结构"></p><a id="more"></a><p>1、list模板类</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> _list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">link_type node;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> _list_node&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">void_pointer prev;</span><br><span class="line">void_pointer next;</span><br><span class="line">T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、迭代器iterator</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Ref</span>,<span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">list_iterator</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T val;</span><br><span class="line"><span class="keyword">typedef</span> Ref ref;</span><br><span class="line"><span class="keyword">typedef</span> Ptr ptr;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须的五种类别</span></span><br><span class="line"><span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;  <span class="comment">//用来表示迭代器的分类，这里是双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line"><span class="keyword">typedef</span> Ref reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">link_type node;</span><br><span class="line">_list_iterator(<span class="keyword">const</span> iterator&amp; x):node(x.node)&#123;&#125; <span class="comment">//拷贝构造</span></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">&#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); <span class="comment">//调用重载运算符函数</span></span><br><span class="line">&#125;</span><br><span class="line">self&amp; <span class="keyword">operator</span>++()         <span class="comment">//++i</span></span><br><span class="line">&#123;node=(link_type)((*node).next);<span class="keyword">return</span> <span class="keyword">this</span>&#125;</span><br><span class="line"><span class="comment">//i++,为了区分两个++,i++带有一个int</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>) </span><br><span class="line"><span class="comment">//先调用拷贝构造，所以不会代用重载的*操作符，但会调用++i</span></span><br><span class="line">&#123;self tmp = *<span class="keyword">this</span>;++*<span class="keyword">this</span>;<span class="keyword">return</span> tmp;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面用一个算法函数解释怎样使用iterator</span></span><br><span class="line">roate(_first,_middle,_end,<span class="built_in">std</span>::_iterator_category)  <span class="comment">//必须Type1</span></span><br><span class="line">&#123;</span><br><span class="line">...::difference_type _Distance;                     <span class="comment">//必须Type2</span></span><br><span class="line">...::value_type _ValueType;                          <span class="comment">//必须Type3</span></span><br><span class="line"><span class="comment">//...::reference和pointer                        //必须Type4,5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/21/STL源码-list/list%E4%B8%ADtraits.png" alt="list中traits"><br>迭代器是泛化指针。对于传递的是类类型名，算法可以通过作用域符::来想iterator提问五种类型。<br>标准库还规定了可以算法可以接受指针参数，此时不能通过作用域直接提问，那该怎么办呢？<br>解决计算机问题的尚方宝剑是：中间层。<br><img src="/2019/04/21/STL源码-list/traits%E5%8C%BA%E5%88%86%E6%8C%87%E9%92%88%E5%92%8C%E7%B1%BB.png" alt="traits区分指针和类"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//偏特化版本</span></span><br><span class="line">(<span class="number">2</span>) <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">3</span>) <span class="keyword">template</span> &lt;calss T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//于是我们可以这样问value_type的内容：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I,...&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(...)</span></span>&#123;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个声明迭代器，迭代器指向容器和调用算法来具体说明调用过程。<br>list<int> mylist;                                         //声明容器<br>list<int>::iterator itlistbeg = mylist.begin();      //定义两个迭代器<br>list<int>::iterator itlistend = mylist.end();        //<br>distance(itlistbeg,itlistend);                         //调用算法，返回两个迭代器的距离</int></int></int></p><p>(1)产生一个模板类对象mylist，负责存储int型数据，算法与模板类对象没有任何关联。<br>(2)定义两个迭代器itlistbeg和itlistend，类型是模板类实例化之后的一种迭代器类型<br>    在list模板类中这样定义iterator：typedef _list_iterator&lt;T,T&amp;,T<em>&gt; iterator<br>    也就是用_list_iterator&lt;T,T&amp;,T</em>&gt; 定义了迭代器对象。<br>    接着使用list模板类的成员函数begin()和end()为迭代器对象赋值，使其指向这个模板类。<br>(3)使用模板函数distance，会根据实参推断出模板参数类型，在算法内部会将这个类型传递给萃取机<br>    iterator_traits，从而提取出算法需要的5中类型。</p><p>备注:这里typename的作用是这样的：对于iterator_traits<i>::value_type中，编译器并不知道<br>value_type是成员变量还是类型名，我们加上typename是告诉编译器这是一个类型名，避免产生歧义。</i></p><p>我们知道了value_type是怎样通过中间层iterator_traits问答的，下面给出五个问题的完整定义。<br>模板定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line">为了兼容指针的两个偏特化版本</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;I *&gt;&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> I value_type ;</span><br><span class="line"><span class="keyword">typedef</span> ptrdiff difference_type;</span><br><span class="line"><span class="keyword">typedef</span> I* pointer;</span><br><span class="line"><span class="keyword">typedef</span> I&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const I *&gt;&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> I value_type ;</span><br><span class="line"><span class="keyword">typedef</span> ptrdiff difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> I* pointer;</span><br><span class="line"><span class="keyword">typedef</span> consy I&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;list在标准库中被定义成双向链表，接下来我们重点介绍list模板类，list的迭代器&lt;br&gt;和解决算法与迭代器的问答关系的萃取机–iterator_traits。&lt;br&gt;&lt;img src=&quot;/2019/04/21/STL源码-list/list%E7%BB%93%E6%9E%84.png&quot; alt=&quot;list结构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="STL" scheme="http://yoursite.com/categories/STL/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>cplusplus三大特性</title>
    <link href="http://yoursite.com/2019/04/19/cplusplus%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/19/cplusplus三大特性/</id>
    <published>2019-04-19T06:41:21.000Z</published>
    <updated>2019-04-19T06:46:55.764Z</updated>
    
    <content type="html"><![CDATA[<p>讲解C++的继承、多态机制。</p><a id="more"></a><p>单继承格式<br>class 类名:继承方式 基类名<br>{<br>派生类新成员；<br>};<br>多继承格式<br>class 类名:继承方式 基类名 继承方式 基类名<br>{</p><p>};<br>继承方式有三种：<br>private ：私有继承，基类中的共有成员和保护成员在子类中均表现为私有成员，不能被派生类的子类访问。<br>           编译器会理解成类型为derived的对象同时也是类型为base的对象，但类型为base的对象不是类型为derived的对象。这点很重要。<br>protected ：保护继承，基类中的共有成员和私有成员均表现为保护成员，可以被派生类成员函数访问和友元函数访问。<br>public ：共有继承，基类的所有成员保留原格式。<br>友元函数不能被继承<br>static成员无论有多少个继承始终就一个，并且访问static用 类名::成员<br>重定义：派生类中与基类同名的函数将覆盖掉基类的函数。<br>多重继承与二义性<br>说明：在多重继承中，若两个或多个类的成员函数有同名的，在派生类调用这个成员函数时如果不指定作用域，就会产生二义性。<br>    class A{<br>    public:<br>        void f();<br>    }</p><pre><code>class B{public:    void f();    void g();}class C:public A,public B{public:    void g();    void h();};</code></pre><p>C c;<br>c.f()就会产生二义性。<br>有三种解决办法<br>法一：调用时指定作用域<br>c.B::f()<br>法二：派生类中同名覆盖<br>    class C:public A,public B{<br>    public:<br>        void g();<br>        void h();<br>        void f()<br>        {<br>            A::f();<br>        }<br>    };<br>法三：虚基类？？？</p><p>C++多态<br>多态可以概括为“一个接口，多种方法”，程序在运行时才决定调用那种方法。C++的多态是通过虚函数来实现的。<br>多态的作用：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。<br>             也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。<br>早绑定：函数的调用，如果在编译期间就知道函数的地址，就是早绑定<br>晚绑定：函数调用的地址不是在编译时知道的而是在运行时确定的。</p><p>这里重点讲解虚函数表：<br>    虚函数表<br>    1、虚函数表是在对象被创建的时候生成的，每一个对象对应一张虚函数表<br>    2、虚函数表中存有对象的所有函数，包括从基类继承的，没有被派生类覆盖的<br>    3、键关系图<br>    至少包含一个纯虚函数的类是抽象类，抽象类不能实例化对象。<br>    接口中不予许含有成员变量，但可以含有静态变量，不可以有构造函数，但一定要有纯虚析构函数<br>    虚函数就可以执行动态绑定。纯虚函数是在虚函数的末尾加入=0;<br>    <img src="/2019/04/19/cplusplus三大特性/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png" alt="虚函数表"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解C++的继承、多态机制。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>cplusplus友元</title>
    <link href="http://yoursite.com/2019/04/19/cplusplus%E5%8F%8B%E5%85%83/"/>
    <id>http://yoursite.com/2019/04/19/cplusplus友元/</id>
    <published>2019-04-19T06:38:55.000Z</published>
    <updated>2019-04-19T06:40:12.478Z</updated>
    
    <content type="html"><![CDATA[<p>讲解C++友元在使用时注意事项</p><a id="more"></a><p>友元函数可以访问类的私有成员和保护成员。<br>友元分为友元函数和友元类<br>友元函数：在类中用friend声明，在类外面直接定义，可不用指定类名和friend，友元函数的参数一般会接受一个类对象，用这个类对象访问类中私有成员。</p><p>友元类：在一个类中用friend声明的类叫友元类，整个类的成员函数都是友元函数。<br>    #include “stdafx.h”<br>    #include <iostream><br>    using namespace std;<br>    class Box<br>    {<br>        double width;<br>    public:<br>        friend void printWidth(Box box);//友元函数<br>        friend class BigBox;            //友元类<br>        void setWidth(double wid);<br>    };<br>    class BigBox<br>    {<br>    public:<br>        void Print(int width, Box &amp;box)<br>        {<br>            // BigBox是Box的友元类，它可以直接访问Box类的任何成员<br>            box.setWidth(width);<br>            cout &lt;&lt; “Width of box : “ &lt;&lt; box.width &lt;&lt; endl;<br>        }<br>    };<br>    // 成员函数定义<br>    void Box::setWidth(double wid)<br>    {<br>        width = wid;<br>    }<br>    // 请注意：printWidth() 不是任何类的成员函数<br>    void printWidth(Box box)<br>    {<br>        /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */<br>        cout &lt;&lt; “Width of box : “ &lt;&lt; box.width &lt;&lt; endl;<br>    }<br>    // 程序的主函数<br>    int main()<br>    {<br>        Box box;<br>        BigBox big;</iostream></p><pre><code>    // 使用成员函数设置宽度    box.setWidth(10.0);    // 使用友元函数输出宽度    printWidth(box);    // 使用友元类中的方法设置宽度    big.Print(20, box);    getchar();    return 0;}</code></pre><p>友元函数注意事项：<br>    1、友元函数不是累的成员，所以不能被继承。<br>    2、友元函数可以访问类的成员，但不能访问类的成员函数。<br>    3、一个函数可以是多个类的友元。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解C++友元在使用时注意事项&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>epoll模型学习笔记</title>
    <link href="http://yoursite.com/2019/04/19/epoll%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/19/epoll模型学习笔记/</id>
    <published>2019-04-19T06:34:20.000Z</published>
    <updated>2019-04-19T06:37:48.668Z</updated>
    
    <content type="html"><![CDATA[<p>讲解epoll模型的编程方法，epoll模型的内部原理，以及epoll怎样改进select</p><a id="more"></a><p>epoll模型学习笔记<br>工作方式：<br>LT：缺省方式，同时支持block和no-block socket，在这种做法中，内核告诉我们一个文件描述符是否被就绪了，如果就绪了，你就可以对这个就绪的fd进行IO操作。<br>    如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错的可能性较小。传统的select\poll都是这种模型的代表。<br>ET：高速工作方式，只支持no-block socket。当描述符从未就绪变为就绪态时，内核通过epoll告诉你。然后他就假设你知道文件描述符已经就绪，不再为这个描述符<br>    提供更多就需通知。直到你做了某些操作使得那个文件描述符不再就绪。<br>区别：LT事件不会丢弃，只要读buffer中有数据可以读取，就不断的通知你。而ET只有在事件发生时才通知。</p><p>使用方式<br>//创建一个epoll句柄，size告诉内核监听的数目<br>    1、int epoll_create(int size)<br>//epoll事件注册函数<br>    2、epoll_ctl(int epfd,int op,int fd,struct epoll_event* event)<br>　　参数epfd为epoll的句柄；<br>　　参数op表示动作，用3个宏来表示：EPOLL_CTL_ADD(注册新的fd到epfd)，EPOLL_CTL_MOD(修改已经注册的fd的监听事件)，EPOLL_CTL_DEL(从epfd删除一个fd)；<br>　　参数fd为需要监听的标示符；<br>　　参数event告诉内核需要监听的事件,event结构<br>    struct epoll_event{<br>        _uint32_t events;<br>        epoll_data data;<br>    };<br>   typedef union epoll_data {<br>       void        *ptr;<br>       int          fd;<br>       uint32_t     u32;<br>       uint64_t     u64;<br>    }epoll_data_t;</p><pre><code>events可以用以下几个宏： EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</code></pre><p>　　EPOLLOUT：表示对应的文件描述符可以写<br>　　EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）<br>　　EPOLLERR：表示对应的文件描述符发生错误<br>　　EPOLLHUP：表示对应的文件描述符被挂断；<br>　　EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的<br>　　EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里<br>//等待事件发生，类似select调用。<br>    3、int epoll_wait(int epfd,struct epoll_event* events,int maxevents,int timeout)<br>    events: 表示从内核得到事件的集合<br>    maxevents: 告知内核这个events有多大，它不能大于epoll_create的size。<br>    timeout：超时时间(ms)(0立即返回，-1永久等待)<br>    返回值：需要处理的事件数目，0代表超时，-1代表失败。</p><p>Select、poll和epoll的对比：<br>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024。<br>epoll的实现机制：<br>（1）调用epoll_create时，做了以下事情：<br>内核帮我们在epoll文件系统里建了个file结点；<br>在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket；<br>建立一个list链表，用于存储准备就绪的事件。<br>（2）调用epoll_ctl时，做了以下事情：<br>把socket放到epoll文件系统里file对象对应的红黑树上；<br>给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。<br>（3）调用epoll_wait时，做了以下事情：<br>观察list链表里有没有数据。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已。<br>即：<br>一颗红黑树，一张准备就绪句柄链表，少量的内核cache，解决了大并发下的socket处理问题。<br>执行epoll_create时，创建了红黑树和就绪链表；<br>执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据;<br>执行epoll_wait时立刻返回准备就绪链表里的数据即可。<br>epoll解决了上述三个特点<br>（1）对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。<br>（2）对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解epoll模型的编程方法，epoll模型的内部原理，以及epoll怎样改进select&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://yoursite.com/2019/04/19/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/19/散列表/</id>
    <published>2019-04-19T01:42:32.000Z</published>
    <updated>2019-04-20T03:50:43.505Z</updated>
    
    <content type="html"><![CDATA[<p>讲解散列表的</p><a id="more"></a><p>散列表最适合的求解问题是查找与给定值相等的记录，不适合做范围查找，不适合进行排序和求最大最小值。<br>同义词：如果两个关键字的散列函数值相等，称两个关键字为同义词。<br>散列函数构造方法：<br>线性函数<br>抽取：从关键字中抽取一部分作为散列位置的方法。比如以电话号码电话号码的最后四位。<br>折叠法：<br>余数法：<br>随机数法：<br>处理散列冲突的方法：<br>1、开放定址法：fi(key)=(f(key)+di)%m   (di=1,2,3,4,5…m-1)  这里的di从1开始依次增加。<br>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。<br>沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）<br>为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到<br>开放的地址则表明表中无待查的关键字，即查找失败。<br>2、在散列函数：事先准备多个散列函数。<br>3、连地址法：将所有关键字为同义词的记录存储在单链表中，在散列表中只存储链表的头结点。<br>4、公共溢出区：把所有冲突的关键词找一个公共溢出区。适用于同义词较少的情况。</p><p>代码实现<br>一、开放定址法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY 65536</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;elem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            H-&gt;elem[i] = NULLKEY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash function,the function can be changeable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[addr] != NULLKEY)        <span class="comment">//open addressing</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;</span><br><span class="line">    H-&gt;elem[addr] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[*addr] != key)</span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;elem[*addr] == NULLKEY || *addr == Hash(key))</span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    InitHashTable(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> elem[<span class="number">12</span>] = &#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(h,elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h-&gt;elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SearchHash(h,h-&gt;elem[i],&amp;addr) == SUCCESS)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,addr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、链地址法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY 65536</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hashnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;HashNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HashNode *head[HASHSIZE];</span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            H-&gt;head[i] = (HashNode *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(HashNode));</span><br><span class="line">            H-&gt;head[i]-&gt;data = NULLKEY;</span><br><span class="line">            H-&gt;head[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash function,the function can be changeable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key);</span><br><span class="line">    HashNode *node = (HashNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashNode));</span><br><span class="line">    HashNode *tmp = H-&gt;head[addr]-&gt;next;</span><br><span class="line"></span><br><span class="line">    node-&gt;data = key;</span><br><span class="line">    node-&gt;next = tmp;</span><br><span class="line"></span><br><span class="line">    H-&gt;head[addr]-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashNode *tmp;</span><br><span class="line">    *addr = Hash(key);</span><br><span class="line"></span><br><span class="line">        tmp = H-&gt;head[*addr]-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;data == key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"find the key\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">    HashNode *tmp;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    InitHashTable(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> elem[<span class="number">12</span>] = &#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(h,elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = h-&gt;head[i]-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp-&gt;data);</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SearchHash(h,elem[i],&amp;addr) == SUCCESS)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,addr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解散列表的&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://yoursite.com/2019/04/18/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/18/平衡二叉树/</id>
    <published>2019-04-18T13:16:40.000Z</published>
    <updated>2019-04-19T01:16:26.005Z</updated>
    
    <content type="html"><![CDATA[<p>讲解平衡二叉树的定义，相关术语，</p><a id="more"></a><p>定义：是一种平衡二叉树，其中每个节点的左子树和右子树的高度差不大于1.<br>相关术语：<br>平衡因子：二叉树上节点的左子树的高度减去右子树的高度的差值称为平衡因子。<br>最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树。<br>左旋：右孩子的左结点，如果右孩子存在左结点，需要先把他调整为根结点的右结点，然后再追加右孩子的左结点。<br>右旋：左孩子的右结点，如果左孩子存在右结点，需要先把他调整成根节点的左结点，然后再追加左孩子的右结点。<br>构建思想：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因为插入而破坏了树的平衡性，若是，则找出最小不平衡子树，进行相应的旋转，使之成为新的平衡子树。<br>          对于最小不平衡子树根结点BF与它子树的BF符号相反时，说明子树现在的结构与要旋转方向不一至，必须先调整子树结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解平衡二叉树的定义，相关术语，&lt;/p&gt;
    
    </summary>
    
      <category term="pragrom" scheme="http://yoursite.com/categories/pragrom/"/>
    
    
  </entry>
  
</feed>
