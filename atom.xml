<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dreamer</title>
  
  <subtitle>莫厌追欢笑语频，寻思离乱好伤神。闲来屈指从头数，得见清平有几人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-04T14:55:04.963Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>梦的蓝天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell指令</title>
    <link href="http://yoursite.com/2019/04/04/shell%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/04/shell指令/</id>
    <published>2019-04-04T14:50:28.000Z</published>
    <updated>2019-04-04T14:55:04.963Z</updated>
    
    <content type="html"><![CDATA[<p>讲述shell编程中的常用命令：apt<br><a id="more"></a><br>一、apt指令<br>    apt-cache search # ——(package 搜索包)<br>    apt-cache show #——(package 获取包的相关信息，如说明、大小、版本等)<br>    sudo apt-get install # ——(package 安装包)sudo apt-get install # —–(package - - reinstall 重新安装包)<br>    sudo apt-get -f install # —–(强制安装?#”-f = –fix-missing”当是修复安装吧…)<br>    sudo apt-get remove #—–(package 删除包)<br>    sudo apt-get remove - - purge # ——(package 删除包，包括删除配置文件等)<br>    sudo apt-get autoremove –purge # —-(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)<br>    sudo apt-get update #——更新源<br>    sudo apt-get upgrade #——更新已安装的包<br>    sudo apt-get dist-upgrade # ———升级系统<br>    sudo apt-get dselect-upgrade #——使用 dselect 升级<br>    apt-cache depends #——-(package 了解使用依赖)<br>    apt-cache rdepends # ——(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧…)<br>    sudo apt-get build-dep # ——(package 安装相关的编译环境)<br>    apt-get source #——(package 下载该包的源代码)<br>    sudo apt-get clean &amp;&amp; sudo apt-get autoclean # ——–清理下载文件的存档 &amp;&amp; 只清理过时的包<br>    sudo apt-get check #——-检查是否有损坏的依赖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述shell编程中的常用命令：apt&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>51单片机扩展RAM与ROM</title>
    <link href="http://yoursite.com/2019/04/04/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%A9%E5%B1%95RAM%E4%B8%8EROM/"/>
    <id>http://yoursite.com/2019/04/04/51单片机扩展RAM与ROM/</id>
    <published>2019-04-04T05:05:58.000Z</published>
    <updated>2019-04-04T05:05:58.992Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>51单片机RAM与ROM</title>
    <link href="http://yoursite.com/2019/04/04/51%E5%8D%95%E7%89%87%E6%9C%BARAM%E4%B8%8EROM/"/>
    <id>http://yoursite.com/2019/04/04/51单片机RAM与ROM/</id>
    <published>2019-04-04T00:33:42.000Z</published>
    <updated>2019-04-04T01:26:15.823Z</updated>
    
    <content type="html"><![CDATA[<p>讲述51单片机的内存分配形式，进而想清楚单片机程序执行的流程。<br><a id="more"></a><br>51单片机在物理结构上有4个存储空间：<br>1、片内数据存储器<br>2、片外数据存储器<br>3、片内程序存储器<br>4、片外程序存储器<br>对于用户而言，只有三个，片内外统一寻址的程序存储器(MOVC),片内数据存储器(MOV),片外数据存储器(MOVX).<br>51单片机支持64kROM和64kRAM</p><p>程序存储器：<br>    4kROM在片内，此时EA置1即可。再使用片外ROM时，需要将EA接地，POSN接片外ROM的片选信号。当=1时，程序从片内ROM开始执行，当PC值超过片内ROM容量时会自动转向外部ROM空间。<br>    ROM存储结构是：<br>    0000H —— 系统复位，PC指向此处；<br>    0003H —— 外部中断0入口<br>    000BH —— T0溢出中断入口<br>    0013H —— 外中断1入口<br>    001BH —— T1溢出中断入口<br>    0023H —— 串口中断入口<br>    002BH —— T2溢出中断入口<br>    0033H —— 用户ROM<br>    <img src="/2019/04/04/51单片机RAM与ROM/ROM结构.png" alt="ROM结构"><br>数据存取器(RAM)：<br>    物理上分为两大区：00H ~ 7FH即128B内RAM 和 SFR区。<br>    <img src="/2019/04/04/51单片机RAM与ROM/片内RAM.png" alt="片内RAM"><br>51单片机支持的寻址方式：<br>    立即数寻址：立即数寻址又称立即寻址，即指令中直接给出操作数的寻址方式称为立即数寻址。在51系列单片机指令系统中，立即数用前面加“#”号的8位数表示（#data，如#30H）或16位数（#data16，如#2052H）表示。举例说明立即数寻址方式，以传送指令为例。<br>    例：MOV A, #80H ；80H——&gt;A<br>    MOV DPTR, #2000H ；2000H——&gt;DPTR<br>    直接寻址：指令中直接给出操作数地址（dir）的寻址方式称为直接寻址。寻址对象为：1 内部数据存储器，在指令中以直接地址表示；2特殊功能寄存器SFR，在指令中用寄存器名称表示。<br>    例：MOV A, 25H ；内部RAM的（25H）——&gt;A<br>    MOV P0, #45H ；45H——&gt;P0 ,P0为直接寻址的SFR<br>    MOV 30H，20H ；内部RAM的（20H）——&gt;（30H）<br>    寄存器寻址：以通用寄存器的内容为操作数的寻址方式称为寄存器寻址。通用寄存器包括：A、B、DPTR、R0～R7。其中B寄存器仅在乘法、除法指令中为寄存器寻址，在其它指令中为直接寻址。A寄存器可以寄存器寻址，又可以直接寻址（此时写作ACC）。直接寻址和寄存器寻址的差别在于，直接寻址是操作数所在的字节地址（占一个字节），寄存器寻址是寄存器编码出现在指令码中。寄存器寻址速度比直接寻址要快。除上面所指的几个寄存器外，其它特殊功能寄存器一律为直接寻址。<br>    例：MOV A, R0 ；R0——&gt;A，R0为寄存器寻址<br>    MUL AB ；A×B——&gt;BA，A，B为寄存器寻址<br>    MOV B, R0 ；R0——&gt;B，R0为寄存器寻址，B为直接寻址<br>    PUSH ACC ；A的内容入栈，A为直接寻址<br>    ADD A, ACC ；A为寄存器寻址，ACC为直接寻址<br>    寄存器间接寻址：以寄存器中的内容为地址，该地址的内容为操作数的寻址方式称为寄存器间接寻址。能够进行寄存器间接寻址的寄存器有：R0、R1、DPTR，用前面加@表示，如@R0、@R1、@DPTR。寄存器间接寻址的存储空间包括内部数据存储器和外部数据存储器。由于内部数据存储器共有128字节，因此用一字节的R0和R1可间接寻址整个空间。而外部数据存储器最大可达64K，仅R0或R1无法寻址整个空间，为此需要由P2端口提供外部RAM高8位地址，由R0或R1提供低8位地址，由此共同寻址64K字节范围。也可用16位的DPTR寄存器间接寻址64K字节存储空间。在指令中，是对内部RAM还是对外部RAM寻址，区别在于对外部RAM的操作仅有数据传送指令，并且用MOVX作为操作助记符。<br>    例：MOV @R0, A ；A——&gt;以R0内容为地址的内部RAM中<br>    MOVX @DPTR, A ；A——&gt;以DPTR内容为地址的外部RAM中<br>    变址寻址：由寄存器DPTR或PC中的内容加上A累加器内容之和而形成操作数地址的寻址方式称为变址寻址。变址寻址只能对程序存储器中的数据进行寻址操作。由于程序存储器是只读存贮器，因此变址寻址只有读操作而无写操作。在指令符号上采用MOVC的形式。<br>    例：MOVC A, @A+DPTR ；（A+DPTR）——&gt;A<br>    MOVC A, @A+PC ； （PC）+1——PC （（A）+（PC））——&gt;A<br>    位寻址：对位地址中的内容进行位操作的寻址方式称为位寻址。由于单片机中只有内部RAM和特殊功能寄存器的部分单元有位地址，因此位寻址只能对有位地址的这两个空间进行寻址操作。位寻址是一种直接寻址方式，由指令给出直接位地址。与直接寻址不同的是，位寻址只给出位地址，而不是字节地址。<br>    例：SETB 20H ；1——&gt;20H位<br>    MOV 32H, C ；进位Cy（即指令中的C）——&gt;32H位<br>    相对寻址：以当前程序计数器PC的内容为基址，加上指令给出的一字节补码数（偏移量）形成新的PC值的寻址方式称为相对寻址。相对寻址方式只修改PC值，故主要用于实现程序的分支转移。<br>    例：SJMP 08H ；PC+2+08H——&gt;PC （该指令为两字节，所以有PC+2）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述51单片机的内存分配形式，进而想清楚单片机程序执行的流程。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="chips" scheme="http://yoursite.com/tags/chips/"/>
    
  </entry>
  
  <entry>
    <title>滑动串口、OOD数据</title>
    <link href="http://yoursite.com/2019/04/03/%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/04/03/协议/</id>
    <published>2019-04-03T05:47:13.000Z</published>
    <updated>2019-04-03T05:58:55.383Z</updated>
    
    <content type="html"><![CDATA[<p>记录TCP滑动窗口，带外数据和缓冲区<br><a id="more"></a><br>一、带外数据：OOB数据是是传输协议层使用的out of data(带外数据)，来发送一些重要数据。一般不使用与数据相同的通道，而是使用特殊的通道，使得数据不容易被阻塞。TCP协议没有所谓的带外数据，而是使用一种紧急模式：设置URG位为1。在程序中，接受OOB数据将recv中的flag为设置成MSG_OOB（windows），发送OOB数据将send的flag设置成MSG_OOB即可。      </p><p>二、缓冲区<br><img src="/2019/04/03/协议/缓冲区.png" alt="缓冲区"><br>当没有调用recv时，内核接受缓冲区的数据一致存在。<br>由于TCP发送完数据之后需要应答ACK，一致等待应答很浪费时间，此时需要滑动窗口。<br>三、滑动窗口<br><img src="/2019/04/03/协议/滑动窗口1.png" alt="滑动窗口1"><br>在窗口内的数据：#2，#3。已经发送但还未应答的数据段32-45.TCP会分成四段发送出去：s1,s2,s3,s4。如果已经收到s1，s2，s4但未收到s3。此时接受端发送应答。此时窗口会右移到s3处。为了保证传输顺序。此时TCP等待一段时间之后会重传（重传机制），重传成功后，s3,s4被遗弃确认。不成功s4被丢弃。<br>流量控制：<br>超时重传机制：见上面。<br>累计ACK：TCP并不是对被一个报文段都会ACK，可能会两个报文一起ACK。<br><img src="/2019/04/03/协议/滑动窗口2.png" alt="滑动窗口2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录TCP滑动窗口，带外数据和缓冲区&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>C语言DLL文件产生和调用</title>
    <link href="http://yoursite.com/2019/04/03/C%E8%AF%AD%E8%A8%80DLL%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E5%92%8C%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/03/C语言DLL文件产生和调用/</id>
    <published>2019-04-03T05:33:33.000Z</published>
    <updated>2019-04-04T00:44:09.645Z</updated>
    
    <content type="html"><![CDATA[<p>讲述C/C++产生的DLL文件怎样被C++或C#调用<br><a id="more"></a><br>创建DLL文件，选择win32项目，选择生成DLL<br><img src="/2019/04/03/C语言DLL文件产生和调用/创建.png" alt="创建"><br>添加头文件和.c文件<br>头文件中的声明<br><img src="/2019/04/03/C语言DLL文件产生和调用/声明.png" alt="声明"><br>.c文件中可以定义中间函数，这个中间函数可一直任何普通函数。然后导出函数一定要加<br>_stdcall 并且导出函数一定是要在头文件中用_declsped声明的。<br><img src="/2019/04/03/C语言DLL文件产生和调用/导出.png" alt="导出"><br>3.添加模块文件.def。<br>4.点击生成解决方案就产生了DLL。</p><p>二、C#调用DLL的方法<br>  包含运行时库<br>using System.Runtime.InteropServices;//运行时库<br>将DLL拷贝到根目录<br>导出语法如下：<br><img src="/2019/04/03/C语言DLL文件产生和调用/Csharp导入.png" alt="Csharp导入"><br>4.Area就是一个在C#中直接调用的成员方法。<br>详细网址<br><a href="https://blog.csdn.net/C_xxy/article/details/78998758" target="_blank" rel="noopener">https://blog.csdn.net/C_xxy/article/details/78998758</a></p><p>三、C++调用DLL的方法<br>1、加载DLL库<br>    HINSTANCE hinstLib = LoadLibrary(TEXT(“ytr.dll”));<br>2、声明函数指针<br>    typedef int (__stdcall *MYPROC)(LPWSTR,LPWSTR);<br>    MYPROC ProcAdd;<br>3、函数指针赋值<br>    ProcAdd = (MYPROC)GetProcAddress(hinstLib,”FB_Open”);<br>4、函数指针调用函数<br>    ProcAdd(3,”abc”)    //两个参数的函数指针调用过程<br>5、释放DLL<br>    BOOL fFreeResult = FreeLibrary(hinstLib);<br>用VS查看DLL是多少位的，这里需要注意64为的应用程序不能调用32 为DLL，32 为应用程序也不能调用64为DLL。<br><img src="/2019/04/03/C语言DLL文件产生和调用/查看.png" alt="查看"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述C/C++产生的DLL文件怎样被C++或C#调用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>再读STM32笔记</title>
    <link href="http://yoursite.com/2019/04/03/%E5%86%8D%E8%AF%BBSTM32%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/03/再读STM32笔记/</id>
    <published>2019-04-03T05:25:24.000Z</published>
    <updated>2019-04-03T06:05:39.620Z</updated>
    
    <content type="html"><![CDATA[<p>这些天将STM32的正点原子的历程调了一遍，收获还真不少，为了方便自己理解，现在从接口，编程思路，ARM结构，外设，LWIP，UCOSIII几部分进行一下总结。<br><a id="more"></a><br>一、接口，先了解的接口有：<br>SCCB–DCMI—数字摄像头接口<br>SAI—串行音频接口<br>SDIO—安全数字输入输出接口<br>LTCD—RGB显示屏接口<br>FMC—扩展外部RAM接口<br>二、ARM结构<br>cotexM4CPU的共分7个block，每个block=512M。block3、4、5、6为FMC连接的外部存储器。block0包含flash memory=1M为用户程序存储器。64k的CCMRAM。block1包含还包含192k的SRAM。block2为APB1,2与AHB1,2连接的外设。这些外设当然就是那些接口。cotexM4采用总线矩阵的形式管理取址，取数据，执行的过程。<br><img src="/2019/04/03/再读STM32笔记/总线结构.png" alt="总线结构"><br>由于这种单片机的功能太多，一个引脚对应一种功能太浪费资源。出现了重映射与复用。重映射也就是说一个外设可能对应多种引脚，比如UART0_RX可以和4个引脚对应，这是就可以用重映射到其他引脚。复用就是用来一个引脚的第二三功能。开启复用功能时不需要把一个外设的所有引都打开，只需要打开一个引脚的复用功能就好。<br><img src="/2019/04/03/再读STM32笔记/引脚复用.png" alt="引脚复用"><br>在线升级应用程序IAP<br><img src="/2019/04/03/再读STM32笔记/IAP.png" alt="IAP"><br>中断管理这里先不说，在线升级IAP也先看不明白。<br>三、编程思路<br>HAL库与正点原子的编程思路给了我很多启示 。看梁晓旭率代码也给了我很多启示 。尽量不要一行一行看代码，哪个变量或地址不懂可以直接全局搜索。这样很容易捋清调用关系。用宏定义多个变量，用分号隔开。建立四个缓冲区的循环buffer和乒乓buffer结合在一起。和加入阈值的处理。<br>四、外设。<br>现在调试过得外设有SDRAM，NOR flash，SD卡，摄像头、RTC时钟、分段式内存管理、FATFS文件系统。<br>五、UCOS操作系统<br>主要是学会建立任务，发信号量与互斥信号量、发送消息队列，事件标志组。<br>六LWIP<br>使用network框架可以像linux那样的TCP框架实现数据的收发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天将STM32的正点原子的历程调了一遍，收获还真不少，为了方便自己理解，现在从接口，编程思路，ARM结构，外设，LWIP，UCOSIII几部分进行一下总结。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="chips" scheme="http://yoursite.com/tags/chips/"/>
    
  </entry>
  
  <entry>
    <title>nanoPi配置AP热点</title>
    <link href="http://yoursite.com/2019/04/03/nanoPi%E9%85%8D%E7%BD%AEAP%E7%83%AD%E7%82%B9/"/>
    <id>http://yoursite.com/2019/04/03/nanoPi配置AP热点/</id>
    <published>2019-04-03T05:18:45.000Z</published>
    <updated>2019-04-03T06:05:41.820Z</updated>
    
    <content type="html"><![CDATA[<p>在nanoPi上移植friendly-core的Ubuntu裁剪版操作系统，并通过iw,ip管理网络，<br>通过hostapd搭建AP热点，通过dhcpd动态自动分配子网。<br><a id="more"></a><br>一、AP是无线访问接入点，可以是WiFi，可以是蓝牙，可以将无线网络客户端连接到一起，然后将无线网络连接到以太网。hostapd可以将无线网卡切换成AP/master模式的守护进程。DHCP服务是根据mac地址自动分配ip的进程。DNS服务器是将域名与ip地址建立在数据库的主机。<br>二、配置AP接入点时要确保没有任何一个应用程序占用无线网卡。包括WSP进程。<br>三、nanaopi通过pppoe连接以太网，需要输入用户名与密码。<br>详见网址：<br><a href="https://www.cnblogs.com/ssooking/p/8571749.html" target="_blank" rel="noopener">https://www.cnblogs.com/ssooking/p/8571749.html</a><br>需要注意的是在输入username是要把横向上的字符串清0<br>四、busybox的作用和功能以及在arm版上安装<a href="https://blog.csdn.net/cy_weiyi/article/details/46953233" target="_blank" rel="noopener">https://blog.csdn.net/cy_weiyi/article/details/46953233</a><br>待补充。</p><p>五、管理网络的工具ip，iw，rfkill<br>1、rfkill用于对系统的无线设备进行打开关闭查找<br>sudo rfkill list :列出所有无线设备<br>sudo rfkill block 0  关闭第0个无线设备<br>ip a<br>ip addr add 192.168.1.199 dev eth0<br>ip link set eth0 up/down<br>iw 启动WIFI连接。<br><a href="https://www.blackmoreops.com/2014/09/18/connect-to-wifi-network-from-command-line-in-linux/" target="_blank" rel="noopener">https://www.blackmoreops.com/2014/09/18/connect-to-wifi-network-from-command-line-in-linux/</a><br>sudo -s 进入root目录<br>service networking restart<br>server isc-dhcp-server restart<br>文件 /etc/network/interface 修改动态ip和静态ip,改完之后重启networking服务<br>文件 /etc/hostapd/hostapd.config<br>文件 /etc/dhcp/dhcpd.config<br>rfkill unblock wlan 启动wlan<br>rfkill block wlan wlan<br>ifup wlan 修改配置文件之后的启动网卡。从静态ip到动态ip<br>hostapd /etc/hostapd/hostapd.config<br>dhcpd</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在nanoPi上移植friendly-core的Ubuntu裁剪版操作系统，并通过iw,ip管理网络，&lt;br&gt;通过hostapd搭建AP热点，通过dhcpd动态自动分配子网。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="ways" scheme="http://yoursite.com/tags/ways/"/>
    
  </entry>
  
  <entry>
    <title>编译连接原理</title>
    <link href="http://yoursite.com/2019/04/03/%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/03/编译连接原理/</id>
    <published>2019-04-03T04:51:05.000Z</published>
    <updated>2019-04-04T01:29:03.027Z</updated>
    
    <content type="html"><![CDATA[<p>讲述c语言从.c和.h文件中产生可执行文件的过程，不同变量的存放位置<br>指定链接库的指令。<br><a id="more"></a><br>1、C语言的编译连接原理—-2018/7/4<br>编辑器：编写代码的窗口<br>编译器：检查代码的语法错误，并将其编译成汇编代码<br>汇编器：将编译出的汇编文件编译成一定功能的目标代码。<br>连接器：将目标代码连接成可执行文件。<br>C语言编译原理：<br>c源程序——预编译处理——编译，优化处理——汇编程序——连接程序——可执行文件。<br>预处理：</p><p>#define 宏定义展开<br>条件编译指令：#if/#endif等</p><p>#include<br>处理注释等特殊符号<br>添加行号和文件标识，输出编译错误警告输出行号。</p><p>#pragma被保留，<br>使用gcc -E可以只进行预编译。<br>编译<br>把预编译的文件进行一系列语法分析生成相应的汇编代码。<br>使用gcc -S 生成编译后的汇编代码<br>汇编：汇编器将汇编代码转换成机器可以执行的命令，每一个汇编指令几乎都对应一条机器指令。根据汇编指令与机器指令的对照表一一翻译即可。<br>执行汇编的指令：gcc -c<br>连接：程序运行需要一多个目标文件，以及所依赖的其他库文件。最后生成可执行文件。连接的目的是将各个模块相互引用的部分处理好。<br>静态连接：在编译阶段将静态库加入到可执行文件中去。相当于复制静态链接库。<br>         -l静态库名（是艾欧）<br>动态连接：连接只需要一些描述信息，而程序执行时在从系统中把相应的动态库加载到内存中。linux动态链接库: .so<br>windows动态连接库 .dll<br>2、C语言的编译连接原理—-2018/7/16<br>预编译会把偷吻键全部复制过去，在编译时会保留使用的将要使用的函数，并编译成汇编文件。<br>今天主要针对多个.c ”重定义“问题进行了思考，对于多个.c与.h文件，虽然有预编译指令#ifndef，但是只对单独的.c文件有过滤性，每个.c文件在预编译时都会复制一份.h中的内容。也就是说，一个.c文件包含了多个.h文件，这些.h文件又相互包含，此时#ifndef才起作用。</p><p>备注：将多个静态库打包成一个静态库的方法：<br>问题：<br>    我有多个静态连接库比如A.a,B.a,C.a，并且我并不知道A B C三个库<br>    由那些文件编译而来，现在我想把他们编译成一个库。</p><p>解答：<br>    .a 文件的结构和.tar文件就没有什么区别。 x 命令解出来， a 命令添加， t命令列表</p><pre><code>楼主的要求只需要，假设A.a, B.a C.a 在/usr/local/lib目录下mkdir /tmp/libABCcd /tmp/libABCar x /usr/local/lib/A.aar x /usr/local/lib/B.aar x /usr/local/lib/C.aar cru libABC.a *.oranlib libABC.a</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述c语言从.c和.h文件中产生可执行文件的过程，不同变量的存放位置&lt;br&gt;指定链接库的指令。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>linux并发API</title>
    <link href="http://yoursite.com/2019/04/03/linux%E5%B9%B6%E5%8F%91API/"/>
    <id>http://yoursite.com/2019/04/03/linux并发API/</id>
    <published>2019-04-03T04:43:57.000Z</published>
    <updated>2019-04-03T04:49:34.202Z</updated>
    
    <content type="html"><![CDATA[<p>总结linux中posix 和system V 中相关的多线程与多进程中的API函数，包括：<br>线程创建，设置线程属性，互斥锁，读写锁，条件变量，屏障，信号量，消息队列，共享内存<br><a id="more"></a><br>1、int pthread_attr_init(pthread_attr_t <em>attr)<br>   int pthread_attr_destory(pthread_attr_t </em>attr)</p><p>2、int pthread_equal(pthread_t th1,pthread_t th2)   // 比较两个线程id<br>    pthread_self(void)                                 // 获取自身线程id</p><p>3、int pthread_create(pthread_t tidp,pthread_attr_t <em>restrict attr,void </em>(<em>start_rtn(void </em>)),void <em>arg)   //每个线程提供一个errno副本<br>4、线程退出方式：（1）简单返回：return n<br>                   （2）被同一进程中的其他线程取消<br>                   （3）pthread_exit(void </em>rval_ptr)<br>5、void pthread_join(pthread_t thread,void *<em> rval_ptr) //阻塞等待指定线程退出<br>6、int pthread_cancel(pthread_t tid) //请求同一进程中的其他线程非正常退出<br>7、void pthread_cleanup_push(void (</em>rtn)(void <em>),void </em>arg)    //线程退出时回调函数，将函数依次放到栈中<br>   void pthread_cleanup_pop(int execute);                        //1.清理回调函数 2.execute非0时调用回调函数<br>   //线程执行以下动作时，回调函数才会触发：<br>   (1)调用pthread_exit()<br>   (2)用非0execute调用pthread_cleanup_pop<br>   (3)响应请求取消</p><p>8、int pthread_detach(pthread_t tid)  //将结合态的线程变成分离态的线程<br>9、int pthread_mutex_init(pthread_mutex_t <em>restrict mutex,const pthread_mutexattr_t </em>restrict attr);<br>    int pthread_mutex_destroy(pthread_mutex_t <em>);<br>    int pthread_mutex_lock(pthread_mutex_t </em>);<br>    int pthread_mutex_unlock(pthread_mutex_t <em>);<br>    int pthread_mutex_trylock(pthread_mutex_t </em>);  //如果互斥锁已经被锁住，返回一个错误状态。<br>10、int pthread_mutex_timedlock();<br>11、int pthread_rwlock_init(pthread_rwlock_t <em>restrict attr,const pthread_rwlockattr_t </em>restrict attr) //初始化读写锁<br>    int pthread_rwlock_destory(pthread_rwlock_t <em>rwlock)<br>    int pthread_rwlock_rdlock(pthread_rwlock_t </em>);<br>    int pthread_rwlock_wrlock(pthread_rwlock_t <em>);<br>    int pthread_rwlock_unlock(pthread_rwlock_t </em>);<br>12、pthread_cond_init(pthread_cond_t <em>reatrict cond,const pthread_condattr_t </em>restrict attr);           //初始化条件变量<br>    int pthread_cond_destory(pthread_cond_t <em>);<br>    int pthread_cond_wait(pthread_cond_t </em>restrict cond,pthread_mutex_t *restrict mutex);</p><p>13、int pthread_barrier_init();                            //屏障，同步多个线程，参数省略<br>    int pthread_barrier_destory();<br>    int pthread_barrier_wait(pthread_barrier_t *)      // 屏障等待多个线程</p><p>14、//内存映射(进程)<br>    void<em> mmap(void </em>addr,size_t len,int port,int flags,int fd,off_t offset)  //将文件映射成内存<br>    int munmap(void <em>addr,size_t len)                                            //解除映射，共享内存中的内容写入文件<br>    int msync(void </em>addr,size_t len,int flags)                                  //保证共享内存与文件的内容一致<br>    //XSI共享存储<br>    int shmget(key_t key,size_t size,int flags)                                 //创建或得到共享内存，返回shmid<br>    void <em>shmat(int shmid,const void </em>addr,int flags)                          //将shmget得到的共享内存映射到进程的地址空间，返回被映射的地址<br>    int shmdt(void *addr);                                                       //解除映射</p><p>15、//消息队列<br>    int msgget(key_t key,int msgflag);                                            //IPC_PRIVATE:创建消息队列<br>    int msgctl(key_t key,int cmd,struct msqid_ds<em> buf)                          //设置<br>    ssize_t msgsnd(int msgid,const void</em> msgp,size_t msgsz,int flag)           //消息写入队列  flag常设置成IPC_NOWAIT，空/满不阻塞<br>    int msgrcv(int msgid,const void* msgp,size_t msgsz,int flag)                //从队列中取消息    msgp指向消息的类型，接下来是消息信息</p><pre><code>//用户定义的通用结构：struct msgstru{    long mtype;                    //大于0，消息类型    char mtext[512];                //消息内容};</code></pre><p>16、//system V信号量<br>    int semget(key_t key,int nsems,int semflg)                                  //创建，成功返回信号量的id<br>    int semop(int semid,struct sembuf *sops,unsigned nsops)                    //执行信号量集合上的操作数组，PV操作函数<br>    int semctl(int semid,int semnum,int cmd,union semun arg)                   //实现对信号量的各种控制操作，初始化，删除等</p><pre><code>//POSIX信号量int sem_init(sem_t *sem.int pshared,unsigned value)                        //初始化信号量int sem_wait(sem_t *)                                                         //阻塞当前线程直到sem大于0int sem_post(sem_t *)                                                         //信号量的值加1intsem_destory(sem_t *)                                                       //释放信号量</code></pre><p>17、//条件变量<br>    int pthread_cond_init(pthread_cond_t <em>cond,pthread_condattr_t </em>attr)      //动态初始化条件变量，静态初始化PTHREAD_COND_INITIALIZER<br>    int pthread_cond_wait(pthread_cond_t <em>cond,pthread_mutex_lock </em>lock)      //等待条件变量发信号，同时释放互斥锁<br>    int pthread_cond_signal(pthread_cond_t <em>cond)                                // 只能使一个等待的条件变量编程非阻塞，若有多个条件变量处于等待状态，会按照线程优先级选择<br>    int pthread_cond_broadsignal(pthread_cond_t </em>cond)                          //</p><pre><code>//xxxctl常用命令字IPC_STAT  //取东西IPC_SRT   //设置东西IPC_RMID  //删除</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结linux中posix 和system V 中相关的多线程与多进程中的API函数，包括：&lt;br&gt;线程创建，设置线程属性，互斥锁，读写锁，条件变量，屏障，信号量，消息队列，共享内存&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>C++查漏补缺</title>
    <link href="http://yoursite.com/2019/04/03/C-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>http://yoursite.com/2019/04/03/C-查漏补缺/</id>
    <published>2019-04-03T00:44:16.000Z</published>
    <updated>2019-04-03T12:28:30.362Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录使用C++的过程中的不足和tips<br><a id="more"></a><br>C语言知识盲点<br>一、c register and static用法<br>    1、register变量将被频繁调用，请求编译器尽可能存在cpu中，而不是内存中<br>        注意：<br>        register变量必须是被cpu寄存器接受的值。<br>        register变量不能用取地址符&amp;<br>        只有局部变量和形参可以用static，全局变量和静态变量不可以<br>    2、static关键字的作用<br>        首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0</p><p>二、#define的高级用法——定义复杂函数,只是没有{}，语句结尾没有分号<br>    用#define和连接符可以定义复杂函数<br>    比如：</p><pre><code>#define swap(a.b) do{\    int t = 0;\    t=a;\    a=b;\    b=t;\    }while(0)</code></pre><p>三、虚函数表<br>    1、虚函数表是在对象被创建的时候生成的，每一个对象对应一张虚函数表<br>    2、虚函数表中存有对象的所有函数，包括从基类继承的，没有被派生类覆盖的<br>    3、键关系图<br>    至少包含一个纯虚函数的类是抽象类，抽象类不能实例化对象。<br>    接口中不予许含有成员变量，但可以含有静态变量，不可以有构造函数，但一定要有纯虚析构函数<br>    虚函数就可以执行动态绑定。纯虚函数是在虚函数的末尾加入=0;<br>    <img src="/2019/04/03/C-查漏补缺/虚函数表.png" alt="虚函数表"><br>四、#undefined 临时关闭一个#define的宏<br>五、指针数组与指向指针的数组，引出指针运算的结合顺序：<br>        在无括号时，从右向左解释；有括号时，先解释括号中的内容，然后再说明按照从右向左的顺序解释<br>        typedef int Patharc[10];<br>        void shortPath(MGrath g,Patharc <em>p)<br>        形参的类型：int (</em>p)[10],说明p是一个指向数组的指针<br>        特别注意的一点是：行指针与指针数组都需要先申请内存才能用。<br>六、深拷贝和浅拷贝主要针对指针来说，对于存在指针变量的对象，执行浅拷贝时没有分离两个对象的关联。此时需要自定义深拷贝构造函数<br>     原则是：对于值类型直接赋值，指针类型要重新分配内存空间。<br>     拷贝构造函数形式：类名(类名 &amp;,…)<br>七、C++使用默认参数<br>    1、在声明中指定默认参数，在定义时要省略这个参数<br>    2、若不声明，可以在定义中直接指定默认参数<br>    double sqrt(double f = 1.0); //函数声明</p><pre><code>double sqrt(double f)  //函数定义{  // ....  }</code></pre><p>八、函数指针作为形参有两种形式<br>    1、直接在形参的位置声明一个函数指针—void Mysort(vector<int> v,bool (*cmp)(const int a,const int b))<br>    2、使用typedef定义一种函数指针新类型，然后在形参处使用这种类型定义的变量相当于函数指针了。<br>九、c register and static用法<br>    1、register变量将被频繁调用，请求编译器尽可能存在cpu中，而不是内存中<br>        注意：<br>        register变量必须是被cpu寄存器接受的值。<br>        register变量不能用取地址符&amp;<br>        只有局部变量和形参可以用static，全局变量和静态变量不可以<br>    2、static关键字的作用<br>        首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0<br>十、#define的高级用法——定义复杂函数,只是没有{}，语句结尾没有分号<br>    用#define和连接符可以定义复杂函数<br>    比如：</int></p><pre><code>#define swap(a.b) do{\    int t = 0;\    t=a;\    a=b;\    b=t;\    }while(0)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录使用C++的过程中的不足和tips&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>python笔记</title>
    <link href="http://yoursite.com/2019/04/02/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/02/python笔记/</id>
    <published>2019-04-02T05:16:00.000Z</published>
    <updated>2019-04-03T05:36:02.138Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记<br><a id="more"></a></p><p>一、dict使用<br>    1、创建{}<br>    2、使用dict()将含有双值子序列的序列转化成字典<br>    3、使用update()合并两个字典，若有重复则替换<br>    4、使用del删除指定key的字典<br>    5、使用clear()或指向一个{}清空dict<br>    6、使用in判断键值是否在字典中<br>    7、使用keys()获取所有键。使用values获取所有值<br>    8、使用items获取所有键值对，每一个键值对用tuple形式存储，整体用list存储<br>二、tuple使用<br>    1、创建， </p><p>三、函数<br>    1、yield 创建迭代器函数使用的关键字，每一次迭代遇到yield就返回其后的值，下一次迭代从此处(函数处)开始。<br>        def my_range(first=0,last=5,step=1):<br>            number = first<br>            while number &lt; last:<br>                yield number<br>                number += step</p><p>四、类<br>    1、self 指向这个被创建的对象本身<br>    2、对象调用成员函数做的两件事：<br>        a、找到对象所属的类<br>        b、将对象传递给成员函数的self参数<br>    3、super()方法<br>    4、属性 name=property(get,set)<br>    5、名称重整：<strong>name<br>    6、@classmethod 类方法，@staticmethod 静态方法<br>    7、iterator和iteratable：重要的两个方法：</strong>iter__()：返回迭代器本身<br>                                             <strong>next</strong>():返回当前值<br>                                                       :改变iterator状态<br>    8、generator 只要包含<strong>iter</strong>()和<strong>next</strong>()即可，但直接用yield也可以。有两种使用方式：next()和send()<br>    9、特殊方法，其实就是运算符重载<br>五、@abstractmethod方法<br>    python中的接口必须借助ABC模块使用–from abc import AECMeta,abstarctmethod<br>    @abstractmethod<br>    def 方法名():</p><pre><code>@abstractmethod方法必须被子类重载。带@abstractmethod的方法不能实例化        </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>vim学习笔记(一)</title>
    <link href="http://yoursite.com/2019/04/02/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/04/02/vim学习笔记一/</id>
    <published>2019-04-02T02:31:56.000Z</published>
    <updated>2019-04-04T14:49:23.220Z</updated>
    
    <content type="html"><![CDATA[<p>常用vim指令<br><a id="more"></a><br>撤销：u<br>复制和粘贴：在退出编辑后。v+移动光标+y(复制)+p(粘贴)  –yump(复制)，put(放置)<br>批量缩进：  在退出编辑后。:24,26&gt;  –右移，:24,26&lt; –左移<br>修改指令别名：<br>    以下是一种改完之后永久生效的方法<br>    1、在用户的家目录找到.bashrc,vim ~/.bashrc<br>    2、在.bashrc中添加修改别名语句：alias wmysql=’mysql -u root -pxidianicelab313’，保存退出<br>    3、在终端使.bashrc生效（不用重启）：source ~/.bashrc</p><p>备注：source指令：使当前shell读入文件路径并以此执行文件中的指令，用于执行刚修改的初始化文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用vim指令&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://yoursite.com/2019/02/03/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/03/二叉排序树/</id>
    <published>2019-02-03T14:53:58.000Z</published>
    <updated>2019-04-03T15:13:50.157Z</updated>
    
    <content type="html"><![CDATA[<p>讲述二叉排序树的插入，查找，删除操作<br><a id="more"></a><br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TRUE 1</span></span><br><span class="line"><span class="comment">#define FALSE 0</span></span><br><span class="line"></span><br><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    struct BiTNode *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SearchBST(BiTree T,<span class="keyword">int</span> key,BiTree f,BiTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild,key,T,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild,key,T,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> InsertBST(BiTree *T,<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree s;</span><br><span class="line">    BiTree p = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">    <span class="keyword">if</span>(SearchBST(*T,key,<span class="keyword">NULL</span>,&amp;p) == <span class="keyword">FALSE</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lchild=s-&gt;rchild=<span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">NULL</span>)      <span class="comment">//haven't root node</span></span><br><span class="line">            *T = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p-&gt;data)</span><br><span class="line">            p-&gt;lchild = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; p-&gt;data)</span><br><span class="line">            p-&gt;rchild = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Delete(BiTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line">    BiTree q,s;</span><br><span class="line">    d=(*p)-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((*p)-&gt;rchild == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;</span><br><span class="line">        free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;</span><br><span class="line">        free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        s=(*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q!=*p)</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        free(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DeleteBST(BiTree *T,<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*T == <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == (*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt;(*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">62</span>,<span class="number">88</span>,<span class="number">58</span>,<span class="number">73</span>,<span class="number">99</span>,<span class="number">93</span>,<span class="number">41</span>,<span class="number">51</span>,<span class="number">35</span>,<span class="number">37</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    BiTree *T = (BiTree *)malloc(sizeof(BiTNode));</span><br><span class="line">    BiTree f;</span><br><span class="line">    BiTree *p = (BiTree *)malloc(sizeof(BiTNode));</span><br><span class="line">    <span class="comment">//create a Binary Tree</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">        InsertBST(T,arr[i]);</span><br><span class="line">    <span class="keyword">int</span> d = DeleteBST(T,<span class="number">88</span>);</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：这里特别强调主函数中传递的实参T，必须用malloc申请内存，应为InsertBST中使用了指针*T。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述二叉排序树的插入，查找，删除操作&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
