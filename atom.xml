<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dreamer</title>
  
  <subtitle>莫厌追欢笑语频，寻思离乱好伤神。闲来屈指从头数，得见清平有几人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-19T06:08:54.097Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>梦的蓝天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>散列表</title>
    <link href="http://yoursite.com/2019/04/19/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/19/散列表/</id>
    <published>2019-04-19T01:42:32.000Z</published>
    <updated>2019-04-19T06:08:54.097Z</updated>
    
    <content type="html"><![CDATA[<p>讲解散列表的<br><a id="more"></a><br>散列表最适合的求解问题是查找与给定值相等的记录，不适合做范围查找，不适合进行排序和求最大最小值。<br>同义词：如果两个关键字的散列函数值相等，称两个关键字为同义词。<br>散列函数构造方法：<br>线性函数<br>抽取：从关键字中抽取一部分作为散列位置的方法。比如以电话号码电话号码的最后四位。<br>折叠法：<br>余数法：<br>随机数法：<br>处理散列冲突的方法：<br>1、开放定址法：fi(key)=(f(key)+di)%m   (di=1,2,3,4,5…m-1)  这里的di从1开始依次增加。<br>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。<br>沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）<br>为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到<br>开放的地址则表明表中无待查的关键字，即查找失败。<br>2、在散列函数：事先准备多个散列函数。<br>3、连地址法：将所有关键字为同义词的记录存储在单链表中，在散列表中只存储链表的头结点。<br>4、公共溢出区：把所有冲突的关键词找一个公共溢出区。适用于同义词较少的情况。</p><p>代码实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY 65536</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;elem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            H-&gt;elem[i] = NULLKEY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash function,the function can be changeable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[addr] != NULLKEY)        <span class="comment">//open addressing</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;</span><br><span class="line">    H-&gt;elem[addr] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[*addr] != key)</span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;elem[*addr] == NULLKEY || *addr == Hash(key))</span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    InitHashTable(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> elem[<span class="number">12</span>] = &#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(h,elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h-&gt;elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SearchHash(h,h-&gt;elem[i],&amp;addr) == SUCCESS)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,addr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解散列表的&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://yoursite.com/2019/04/18/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/18/平衡二叉树/</id>
    <published>2019-04-18T13:16:40.000Z</published>
    <updated>2019-04-19T01:16:26.005Z</updated>
    
    <content type="html"><![CDATA[<p>讲解平衡二叉树的定义，相关术语，<br><a id="more"></a><br>定义：是一种平衡二叉树，其中每个节点的左子树和右子树的高度差不大于1.<br>相关术语：<br>平衡因子：二叉树上节点的左子树的高度减去右子树的高度的差值称为平衡因子。<br>最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树。<br>左旋：右孩子的左结点，如果右孩子存在左结点，需要先把他调整为根结点的右结点，然后再追加右孩子的左结点。<br>右旋：左孩子的右结点，如果左孩子存在右结点，需要先把他调整成根节点的左结点，然后再追加左孩子的右结点。<br>构建思想：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因为插入而破坏了树的平衡性，若是，则找出最小不平衡子树，进行相应的旋转，使之成为新的平衡子树。<br>          对于最小不平衡子树根结点BF与它子树的BF符号相反时，说明子树现在的结构与要旋转方向不一至，必须先调整子树结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解平衡二叉树的定义，相关术语，&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="pragrom" scheme="http://yoursite.com/categories/pragrom/"/>
    
    
  </entry>
  
  <entry>
    <title>freeBSD学习笔记</title>
    <link href="http://yoursite.com/2019/04/18/freeBSD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/18/freeBSD学习笔记/</id>
    <published>2019-04-18T07:44:12.000Z</published>
    <updated>2019-04-18T08:25:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>Linux各种混乱 不堪的发行版相比，FreeBSD只有唯一的版本，同时，FreeBSD关注的是操作系统的稳定性、性能和品质，适合作为服务器的操作系统。<br><a id="more"></a><br>三个主流的linux发行版：Red Hat、Mandrake和SUSE。每一个Linux发行版本都存在一些差异，而它们之间最大的差异则在于文件系统的结构。</p><p>FreeBSD使用“包”来安装、卸载和升级应用程序。‘pkg_add’命令被用于安装一个你手工下载到计算机的包。你也可以用‘-r’开关来让 它自动的从<br>Internet获取，当然，也包括这个包所依赖的一切。FreeBSD包的真正美妙之处在于“连接点”(Ports)树。连接点树是 ——FreeBSD包含的应用程序<br>之间的继承关系。每一个文件夹都包含Makefile，以及让特定应用程序能够在FreeBSD上正确运行所需要的补丁。例如，如果我想安装<br>Apache web服务器，我所需要做的只是cd到/usr/ports/www/apache文件夹，然后运行‘make &amp;&amp; make install’，然后去小吃售卖机前。<br>如果我拥有一台速度够快的电脑，同时拥有一个足够大方的Internet连接，当我回来的时候Apache源代码 的下载、补丁、编译和安装<br>肯定都已经做完了。连接点树也能够处理Apache运行依赖的那些程序，无论我用连接点树安装、手工编译，还是通过安装已经编译<br>好的二进制包。连接点树能够通过$PATH找到它需要的东西。<br>Linux和FreeBSD的另一个区别在于，对于FreeBSD而言，你安装的连接点或者包99%都会被放到/usr/local，而在 Linux上有时是/usr，<br>有时是/opt。这可能只是一个很小的区别，但你至少可以知道你的程序安装到了/usr/local，而不是扩散到了文件系 统的各个地方。</p><p>FreeBSD系统使用cvsup来保持它是最新的。一旦你建立了‘sup-file’，cvsup将会把你本地的系统和cvsup服务器上的进行比较，并且下载那些修改过的东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux各种混乱 不堪的发行版相比，FreeBSD只有唯一的版本，同时，FreeBSD关注的是操作系统的稳定性、性能和品质，适合作为服务器的操作系统。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="freeBSD" scheme="http://yoursite.com/categories/freeBSD/"/>
    
    
  </entry>
  
  <entry>
    <title>sed指令</title>
    <link href="http://yoursite.com/2019/04/17/sed%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/17/sed指令/</id>
    <published>2019-04-17T04:26:54.000Z</published>
    <updated>2019-04-17T04:31:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题来源于怎样通过shell指令查找、替换多个文件中的某字符串<br><a id="more"></a><br>vim在编译模式下进行多文件查找与替换</p><p>替换<br>在一个文件中在vim的编辑模式下这样替换：<br>:25,52s/addr/abcdefg/cg     #将文件中addr替换成abcdefg，c：每次替换会询问，g：全部替换<br>sed指令介绍<br>sed指令把处理的行存入临时缓冲区中，接着用sed指令处理缓冲区的内容，处理完之后把缓冲区的内容送到屏幕<br>但是文件中的内容并没有改变，如果想改变文件中的内容，可以用参数i<br>格式：<br>1、sed [options] ‘指令’ files<br>2、sed [options] -f 脚本 files<br>其中’指令’处可以是正则表达式，正则表达式用/…/分隔<br>替换：<br>1、sed ’s/book/books/‘ files         # s 替换<br>2、sed -n ‘s/book/books/p’ files     # -n -p 结合只用于输出改变的行<br>3、sed ‘s/book/books/g’    files     # g：全部替换<br>4、sed ’s/book/books/ng’   files     # 从n处开始替换<br>5、sed -i ‘s/book/books/g’  files    # 直接编辑文本<br>6、sed -i ‘s/$/abcdefh/g’ files      # 每行的末尾加入abcdefh<br>删除：<br>删除空白行：sed -i ‘/^$/d’ files<br>删除第n行： sed -i ‘/4/d’ files<br>指定删除范围： sed -i ‘2,$/d’ files<br>删除最后一行： sed -i ‘$/d’ files<br>删除文件所有以test开头的行：sed ‘/^test/d’ files</p><p>多个sed组合<br>sed ‘表达式’ | sed ‘表达式’</p><p>-e选项，允许在同一条指令中执行多条语句<br>例如：sed -e ‘1,5d’ -e ‘s/test/abcdef/g’ files<br>第一条语句会对第二条造成影响</p><p>选定行的范围<br>sed -n ‘/test/,/check/p’ files<br>例如：sed -n ‘/5,/^test/p’ files<br>w:写入文件指令(这条指令完全可以用重定向解决)<br>sed -n ‘/test/w file’ example     # 在example中所有包含test的行都被写入到file中，且file被清空</p><p>a\命令 行后添加一行<br>sed ‘/return/this is a line’ client.cpp    # 在client.cpp中包含return的行后面添加this is a line<br>i\命令 行前添加<br>sed ‘/2i\’this is a line’ client.cpp</p><p>注意：<br>1、sed默认使用单引号来引用，但是表达式内部包含变量字符串是，需要用双引号<br>    test=hello<br>    echo hello WORLD | sed “s/$test/HELLO</p><p>awk指令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个问题来源于怎样通过shell指令查找、替换多个文件中的某字符串&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>工厂类</title>
    <link href="http://yoursite.com/2019/04/08/%E5%B7%A5%E5%8E%82%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/04/08/工厂类/</id>
    <published>2019-04-08T14:37:49.000Z</published>
    <updated>2019-04-08T14:42:28.616Z</updated>
    
    <content type="html"><![CDATA[<p>讲述设计模式之简单工厂类<br><a id="more"></a><br>工厂模式：<br>    简单工厂模式可以理解为负责生产对象的一个类，称为”工厂类”<br>模式原理：<br>![模式组成(工厂类/模式组成.png)]<br>使用步骤：<br>    创建抽象产品类 &amp; 定义具体产品的公共接口；<br>    创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>    创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；<br>    外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例</p><p>使用例子：<br>背景：小成有一个塑料生产厂，用来做塑料加工生意<br>目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：创建抽象产品类：</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    public <span class="keyword">abstract</span> void <span class="type">Show</span>();</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">2</span>：创建具体产品类(继承抽象产品类)，定义生产的具体产品</span><br><span class="line"><span class="comment">//具体产品类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductA</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductB</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductC</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">3</span>：创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类实例。</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    public static <span class="type">Product</span> <span class="type">Manufacture</span>(<span class="type">String</span> <span class="type">ProductName</span>)&#123;</span><br><span class="line"><span class="comment">//工厂类里用switch语句控制生产哪种商品；</span></span><br><span class="line"><span class="comment">//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。</span></span><br><span class="line">        switch (<span class="type">ProductName</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductA</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductB</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductC</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">4</span>：外部调用工厂类</span><br><span class="line"><span class="comment">//工厂产品生产流程</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryPattern</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">Factory</span> mFactory = <span class="keyword">new</span> <span class="type">Factory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//调用工厂类的静态方法 &amp; 传入不同参数从而创建产品实例</span></span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"A"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"B"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品C</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"C"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品D</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"D"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述设计模式之简单工厂类&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>子网掩码与网关</title>
    <link href="http://yoursite.com/2019/04/05/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%B8%8E%E7%BD%91%E5%85%B3/"/>
    <id>http://yoursite.com/2019/04/05/子网掩码与网关/</id>
    <published>2019-04-05T12:35:19.000Z</published>
    <updated>2019-04-05T12:38:50.546Z</updated>
    
    <content type="html"><![CDATA[<p>以下我们就来深入浅出地讲解什么是子网掩码。<br><a id="more"></a><br>一、IP地址的结构<br>    要想理解什么是子网掩码，就不能不了解IP地址的构成。互联网是由许多小型网络构成的，每个网络上都有许多主机，<br>    这样便构成了一个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络号和主机号两部分，<br>    以便于IP地址的寻址操作。IP地址的网络号和主机号各是多少位呢？如果不指定，就不知道哪些位是网络号、哪些是主机号，<br>    这就需要通过子网掩码来实现。<br>    对于这样的结构ip/1-32，代表子网掩码中网络号的长度<br>    192.168.1.1/24，网络号长度为24</p><p>二、什么是子网掩码<br>    子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。<br>    子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。</p><p>三、三类IP地址<br>    划分A,B,C三类子网的方式是根据IP地址的第一段信息<br>    A类IP地址：1-126<br>    B类IP地址：128-191<br>    C类IP地址：192-155</p><p>四、网络地址与广播地址<br>    网络地址：IP地址与子网掩码&amp;的结果<br>    广播地址：下一个网段的网络地址-1</p><p>五、网关地址<br>    要实现两个子网之间的通信，必须使用网关。比如A网络向B网络发送数据。A网络的主机发现目的主机不在本局域网内，<br>    就将数据发送到自己的网关，再转发到B网络的网关，再有B网络的网关B发送到次局域网中的目的主机。</p><p>再根据CCNA中会出现的题目给大家举个例子：<br>首先，我们看一个考试中常见的题型：一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址。<br>常规办法是把这个主机地址和子网掩码都换算成二进制数，两者进行逻辑与运算后即可得到网络地址。<br>其实大家只要仔细想想，可以得到另一个方法：255.255.255.224的掩码所容纳的IP地址有256－224＝32个（包括网络地址和广播地址），<br>那么具有这种掩码的网络地址一定是32的倍数。而网络地址是子网IP地址的开始，广播地址是结束，可使用的主机地址在这个范围内，<br>因此略小于137而又是32的倍数的只有128，所以得出网络地址是202.112.14.128。而广播地址就是下一个网络的网络地址减1。而下一个32的倍数是160，<br>因此可以得到广播地址为202.112.14.159。</p><p>子网络 2进制子网络域数 2进制主机域数的范围 2进制主机域数的范围<br>第1个子网络 000 00000 thru 11111 .0 thru.31<br>第2个子网络 001 00000 thru 11111 .32 thru.63<br>第3个子网络 010 00000 thru 11111 .64 thru.95<br>第4个子网络 011 00000 thru 11111 .96 thru.127<br>第5个子网络 100 00000 thru 11111 .128 thru.159<br>第6个子网络 101 00000 thru 11111 .160 thru.191<br>第7个子网络 110 00000 thru 11111 .192 thru.223<br>第8个子网络 111 00000 thru 11111 .124 thru.255 </p><p>CCNA考试中，还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。比如一个子网有10台主机，那么对于这个子网需要的IP地址是：<br>10＋1＋1＋1＝13<br>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。因为13小于16（16等于2的4次方），所以主机位为4位。而<br>256－16＝240<br>所以该子网掩码为255.255.255.240。<br>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为：<br>14＋1＋1＋1＝17<br>17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下我们就来深入浅出地讲解什么是子网掩码。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>shell指令</title>
    <link href="http://yoursite.com/2019/04/04/shell%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/04/shell指令/</id>
    <published>2019-04-04T14:50:28.000Z</published>
    <updated>2019-04-04T14:55:04.963Z</updated>
    
    <content type="html"><![CDATA[<p>讲述shell编程中的常用命令：apt<br><a id="more"></a><br>一、apt指令<br>    apt-cache search # ——(package 搜索包)<br>    apt-cache show #——(package 获取包的相关信息，如说明、大小、版本等)<br>    sudo apt-get install # ——(package 安装包)sudo apt-get install # —–(package - - reinstall 重新安装包)<br>    sudo apt-get -f install # —–(强制安装?#”-f = –fix-missing”当是修复安装吧…)<br>    sudo apt-get remove #—–(package 删除包)<br>    sudo apt-get remove - - purge # ——(package 删除包，包括删除配置文件等)<br>    sudo apt-get autoremove –purge # —-(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)<br>    sudo apt-get update #——更新源<br>    sudo apt-get upgrade #——更新已安装的包<br>    sudo apt-get dist-upgrade # ———升级系统<br>    sudo apt-get dselect-upgrade #——使用 dselect 升级<br>    apt-cache depends #——-(package 了解使用依赖)<br>    apt-cache rdepends # ——(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧…)<br>    sudo apt-get build-dep # ——(package 安装相关的编译环境)<br>    apt-get source #——(package 下载该包的源代码)<br>    sudo apt-get clean &amp;&amp; sudo apt-get autoclean # ——–清理下载文件的存档 &amp;&amp; 只清理过时的包<br>    sudo apt-get check #——-检查是否有损坏的依赖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述shell编程中的常用命令：apt&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>再读STM32笔记</title>
    <link href="http://yoursite.com/2019/04/03/%E5%86%8D%E8%AF%BBSTM32%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/03/再读STM32笔记/</id>
    <published>2019-04-03T05:25:24.000Z</published>
    <updated>2019-04-03T06:05:39.620Z</updated>
    
    <content type="html"><![CDATA[<p>这些天将STM32的正点原子的历程调了一遍，收获还真不少，为了方便自己理解，现在从接口，编程思路，ARM结构，外设，LWIP，UCOSIII几部分进行一下总结。<br><a id="more"></a><br>一、接口，先了解的接口有：<br>SCCB–DCMI—数字摄像头接口<br>SAI—串行音频接口<br>SDIO—安全数字输入输出接口<br>LTCD—RGB显示屏接口<br>FMC—扩展外部RAM接口<br>二、ARM结构<br>cotexM4CPU的共分7个block，每个block=512M。block3、4、5、6为FMC连接的外部存储器。block0包含flash memory=1M为用户程序存储器。64k的CCMRAM。block1包含还包含192k的SRAM。block2为APB1,2与AHB1,2连接的外设。这些外设当然就是那些接口。cotexM4采用总线矩阵的形式管理取址，取数据，执行的过程。<br><img src="/2019/04/03/再读STM32笔记/总线结构.png" alt="总线结构"><br>由于这种单片机的功能太多，一个引脚对应一种功能太浪费资源。出现了重映射与复用。重映射也就是说一个外设可能对应多种引脚，比如UART0_RX可以和4个引脚对应，这是就可以用重映射到其他引脚。复用就是用来一个引脚的第二三功能。开启复用功能时不需要把一个外设的所有引都打开，只需要打开一个引脚的复用功能就好。<br><img src="/2019/04/03/再读STM32笔记/引脚复用.png" alt="引脚复用"><br>在线升级应用程序IAP<br><img src="/2019/04/03/再读STM32笔记/IAP.png" alt="IAP"><br>中断管理这里先不说，在线升级IAP也先看不明白。<br>三、编程思路<br>HAL库与正点原子的编程思路给了我很多启示 。看梁晓旭率代码也给了我很多启示 。尽量不要一行一行看代码，哪个变量或地址不懂可以直接全局搜索。这样很容易捋清调用关系。用宏定义多个变量，用分号隔开。建立四个缓冲区的循环buffer和乒乓buffer结合在一起。和加入阈值的处理。<br>四、外设。<br>现在调试过得外设有SDRAM，NOR flash，SD卡，摄像头、RTC时钟、分段式内存管理、FATFS文件系统。<br>五、UCOS操作系统<br>主要是学会建立任务，发信号量与互斥信号量、发送消息队列，事件标志组。<br>六LWIP<br>使用network框架可以像linux那样的TCP框架实现数据的收发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天将STM32的正点原子的历程调了一遍，收获还真不少，为了方便自己理解，现在从接口，编程思路，ARM结构，外设，LWIP，UCOSIII几部分进行一下总结。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="chips" scheme="http://yoursite.com/tags/chips/"/>
    
  </entry>
  
  <entry>
    <title>编译连接原理</title>
    <link href="http://yoursite.com/2019/04/03/%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/03/编译连接原理/</id>
    <published>2019-04-03T04:51:05.000Z</published>
    <updated>2019-04-04T01:29:03.027Z</updated>
    
    <content type="html"><![CDATA[<p>讲述c语言从.c和.h文件中产生可执行文件的过程，不同变量的存放位置<br>指定链接库的指令。<br><a id="more"></a><br>1、C语言的编译连接原理—-2018/7/4<br>编辑器：编写代码的窗口<br>编译器：检查代码的语法错误，并将其编译成汇编代码<br>汇编器：将编译出的汇编文件编译成一定功能的目标代码。<br>连接器：将目标代码连接成可执行文件。<br>C语言编译原理：<br>c源程序——预编译处理——编译，优化处理——汇编程序——连接程序——可执行文件。<br>预处理：</p><p>#define 宏定义展开<br>条件编译指令：#if/#endif等</p><p>#include<br>处理注释等特殊符号<br>添加行号和文件标识，输出编译错误警告输出行号。</p><p>#pragma被保留，<br>使用gcc -E可以只进行预编译。<br>编译<br>把预编译的文件进行一系列语法分析生成相应的汇编代码。<br>使用gcc -S 生成编译后的汇编代码<br>汇编：汇编器将汇编代码转换成机器可以执行的命令，每一个汇编指令几乎都对应一条机器指令。根据汇编指令与机器指令的对照表一一翻译即可。<br>执行汇编的指令：gcc -c<br>连接：程序运行需要一多个目标文件，以及所依赖的其他库文件。最后生成可执行文件。连接的目的是将各个模块相互引用的部分处理好。<br>静态连接：在编译阶段将静态库加入到可执行文件中去。相当于复制静态链接库。<br>         -l静态库名（是艾欧）<br>动态连接：连接只需要一些描述信息，而程序执行时在从系统中把相应的动态库加载到内存中。linux动态链接库: .so<br>windows动态连接库 .dll<br>2、C语言的编译连接原理—-2018/7/16<br>预编译会把偷吻键全部复制过去，在编译时会保留使用的将要使用的函数，并编译成汇编文件。<br>今天主要针对多个.c ”重定义“问题进行了思考，对于多个.c与.h文件，虽然有预编译指令#ifndef，但是只对单独的.c文件有过滤性，每个.c文件在预编译时都会复制一份.h中的内容。也就是说，一个.c文件包含了多个.h文件，这些.h文件又相互包含，此时#ifndef才起作用。</p><p>备注：将多个静态库打包成一个静态库的方法：<br>问题：<br>    我有多个静态连接库比如A.a,B.a,C.a，并且我并不知道A B C三个库<br>    由那些文件编译而来，现在我想把他们编译成一个库。</p><p>解答：<br>    .a 文件的结构和.tar文件就没有什么区别。 x 命令解出来， a 命令添加， t命令列表</p><pre><code>楼主的要求只需要，假设A.a, B.a C.a 在/usr/local/lib目录下mkdir /tmp/libABCcd /tmp/libABCar x /usr/local/lib/A.aar x /usr/local/lib/B.aar x /usr/local/lib/C.aar cru libABC.a *.oranlib libABC.a</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述c语言从.c和.h文件中产生可执行文件的过程，不同变量的存放位置&lt;br&gt;指定链接库的指令。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>vim学习笔记(一)</title>
    <link href="http://yoursite.com/2019/04/02/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/04/02/vim学习笔记一/</id>
    <published>2019-04-02T02:31:56.000Z</published>
    <updated>2019-04-15T17:21:25.377Z</updated>
    
    <content type="html"><![CDATA[<p>常用vim指令<br><a id="more"></a><br>撤销：u<br>复制和粘贴：在退出编辑后。v+移动光标+y(复制)+p(粘贴)  –yump(复制)，put(放置)<br>批量缩进：  在退出编辑后。:24,26&gt;  –右移，:24,26&lt; –左移<br>修改指令别名：<br>    以下是一种改完之后永久生效的方法<br>    1、在用户的家目录找到.bashrc,vim ~/.bashrc<br>    2、在.bashrc中添加修改别名语句：alias wmysql=’mysql -u root -pxidianicelab313’，保存退出<br>    3、在终端使.bashrc生效（不用重启）：source ~/.bashrc</p><p>备注：source指令：使当前shell读入文件路径并以此执行文件中的指令，用于执行刚修改的初始化文件。</p><p>查看内存:free -m(m为MB，g为GB)<br>                  total        used        free      shared  buff/cache   available<br>    Mem:           3933        1193         358          32        2382        2372<br>    Swap:          4093           9        4084</p><p>查看磁盘:df -lh<br>    Filesystem      Size  Used Avail Use% Mounted on<br>    udev            2.0G     0  2.0G   0% /dev<br>    tmpfs           394M   27M  368M   7% /run<br>    /dev/sda1        16G   14G  1.1G  93% /<br>    tmpfs           2.0G  248K  2.0G   1% /dev/shm<br>    tmpfs           5.0M  4.0K  5.0M   1% /run/lock<br>    tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup<br>    vmhgfs-fuse     292G  156G  137G  54% /mnt/hgfs<br>    cgmfs           100K     0  100K   0% /run/cgmanager/fs<br>    tmpfs           394M   88K  394M   1% /run/user/1000<br>CPU使用：cat /proc/cpuinfo</p><p>查看某个用户可以打开的文件描述符 ulimit -a<br>修改打开的文件描述符<br>临时修改：ulimit -n 20000   (只对当前用户有效)<br>永久修改：vim /etc/security/limits.conf<br>加入：    * soft nofile 4096</p><pre><code>* hard nofile 4096* 代表所有用户，可以根据某个用户修改fdipzone soft nofile 8192fdipzone hard nofile 8192</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用vim指令&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://yoursite.com/2019/02/03/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/03/二叉排序树/</id>
    <published>2019-02-03T14:53:58.000Z</published>
    <updated>2019-04-03T15:13:50.157Z</updated>
    
    <content type="html"><![CDATA[<p>讲述二叉排序树的插入，查找，删除操作<br><a id="more"></a><br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TRUE 1</span></span><br><span class="line"><span class="comment">#define FALSE 0</span></span><br><span class="line"></span><br><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    struct BiTNode *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SearchBST(BiTree T,<span class="keyword">int</span> key,BiTree f,BiTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild,key,T,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild,key,T,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> InsertBST(BiTree *T,<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree s;</span><br><span class="line">    BiTree p = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">    <span class="keyword">if</span>(SearchBST(*T,key,<span class="keyword">NULL</span>,&amp;p) == <span class="keyword">FALSE</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lchild=s-&gt;rchild=<span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">NULL</span>)      <span class="comment">//haven't root node</span></span><br><span class="line">            *T = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p-&gt;data)</span><br><span class="line">            p-&gt;lchild = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; p-&gt;data)</span><br><span class="line">            p-&gt;rchild = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Delete(BiTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line">    BiTree q,s;</span><br><span class="line">    d=(*p)-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((*p)-&gt;rchild == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;</span><br><span class="line">        free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;</span><br><span class="line">        free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        s=(*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q!=*p)</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        free(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DeleteBST(BiTree *T,<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*T == <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == (*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt;(*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">62</span>,<span class="number">88</span>,<span class="number">58</span>,<span class="number">73</span>,<span class="number">99</span>,<span class="number">93</span>,<span class="number">41</span>,<span class="number">51</span>,<span class="number">35</span>,<span class="number">37</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    BiTree *T = (BiTree *)malloc(sizeof(BiTNode));</span><br><span class="line">    BiTree f;</span><br><span class="line">    BiTree *p = (BiTree *)malloc(sizeof(BiTNode));</span><br><span class="line">    <span class="comment">//create a Binary Tree</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">        InsertBST(T,arr[i]);</span><br><span class="line">    <span class="keyword">int</span> d = DeleteBST(T,<span class="number">88</span>);</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：这里特别强调主函数中传递的实参T，必须用malloc申请内存，应为InsertBST中使用了指针*T。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述二叉排序树的插入，查找，删除操作&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
