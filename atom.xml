<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dreamer</title>
  
  <subtitle>莫厌追欢笑语频，寻思离乱好伤神。闲来屈指从头数，得见清平有几人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-23T09:21:46.723Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>梦的蓝天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARP</title>
    <link href="http://yoursite.com/2019/04/23/ARP/"/>
    <id>http://yoursite.com/2019/04/23/ARP/</id>
    <published>2019-04-23T09:02:01.000Z</published>
    <updated>2019-04-23T09:21:46.723Z</updated>
    
    <content type="html"><![CDATA[<p>讲解地址解析协议ARP的工作原理<br><a id="more"></a><br>ARP：将32位IP地址转化成48位MAC地址。<br>每一台主机或路由器中都存在一张ARP表，记录IP地址与MAC地址的映射关系，这种映射关系是这样形成的：<br>当主机A向主机B发送数据包时，<br>先查询ARP表中是否有IP和MAC地址的缓存，如果缓存存在，则将用户数据<br>加入TCP/UDP首部，加入IP首部，加入以太网首部，其中以太网首部包含MAC地址和帧类型(IPv4,IPv6)。<br>如果主机A中不存在主机B的IP与MAC的ARP缓存，主机A发送一个ARP报文，ARP包结构如下：<br><img src="/2019/04/23/ARP/ARP.png" alt="ARP.png"><br>硬件类型（16位）：指定物理地址的类型，1表示以太网。<br>上层协议类型（16位）：指定要将MAC地址映射成什么协议的地址。0x0800表示IP地址。<br>MAC地址长度（8位）：指定MAC地址的长度，单位是字节。<br>协议地址长度（8位）：指定协议地址的长度，单位为字节。<br>操作类型：1表示ARP请求、2表示ARP回应、3表示RARP请求，4表示RARP回应。<br>接下来为发送源的物理地址和协议地址（由于回应时要知道发送给谁，以此来封装以太帧），目的物理地址和协议地址。<br>封装ARP请求时，发送源除了目的物理地址外都会填写。</p><p>ARP请求报文中存主机B的IP地址，MAC地址为FF-FF-FF-FF-FF-FF，代表广播MAC地址。子网中每一台主机收到<br>这个ARP报文后，与报文中的IP地址比较，若想等，将自己的MAC地址放入ARP应答报文中，发送给主机A，同时<br>子网中每一台设备的ARP表中存放主机Ａ的IP和MAC的映射关系。主机A收到ARP应答报文后，在原来的ARP表中追加记录。<br>并发送IP数据报。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解地址解析协议ARP的工作原理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>STL源码-list</title>
    <link href="http://yoursite.com/2019/04/21/STL%E6%BA%90%E7%A0%81-list/"/>
    <id>http://yoursite.com/2019/04/21/STL源码-list/</id>
    <published>2019-04-21T02:50:13.000Z</published>
    <updated>2019-04-21T15:20:15.786Z</updated>
    
    <content type="html"><![CDATA[<p>list在标准库中被定义成双向链表，接下来我们重点介绍list模板类，list的迭代器<br>和解决算法与迭代器的问答关系的萃取机–iterator_traits。<br><img src="/2019/04/21/STL源码-list/list结构.png" alt="list结构"><br><a id="more"></a><br>1、list模板类<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> _list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">link_type node;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点结构体</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> _list_node&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">void_pointer prev;</span><br><span class="line">void_pointer next;</span><br><span class="line">T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>2、迭代器iterator<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Ref</span>,<span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">list_iterator</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T val;</span><br><span class="line"><span class="keyword">typedef</span> Ref ref;</span><br><span class="line"><span class="keyword">typedef</span> Ptr ptr;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须的五种类别</span></span><br><span class="line"><span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;  <span class="comment">//用来表示迭代器的分类，这里是双向链表</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line"><span class="keyword">typedef</span> Ref reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">link_type node;</span><br><span class="line">_list_iterator(<span class="keyword">const</span> iterator&amp; x):node(x.node)&#123;&#125; <span class="comment">//拷贝构造</span></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">&#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); <span class="comment">//调用重载运算符函数</span></span><br><span class="line">&#125;</span><br><span class="line">self&amp; <span class="keyword">operator</span>++()         <span class="comment">//++i</span></span><br><span class="line">&#123;node=(link_type)((*node).next);<span class="keyword">return</span> <span class="keyword">this</span>&#125;</span><br><span class="line"><span class="comment">//i++,为了区分两个++,i++带有一个int</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>) </span><br><span class="line"><span class="comment">//先调用拷贝构造，所以不会代用重载的*操作符，但会调用++i</span></span><br><span class="line">&#123;self tmp = *<span class="keyword">this</span>;++*<span class="keyword">this</span>;<span class="keyword">return</span> tmp;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面用一个算法函数解释怎样使用iterator</span></span><br><span class="line">roate(_first,_middle,_end,<span class="built_in">std</span>::_iterator_category)  <span class="comment">//必须Type1</span></span><br><span class="line">&#123;</span><br><span class="line">...::difference_type _Distance;                     <span class="comment">//必须Type2</span></span><br><span class="line">...::value_type _ValueType;                          <span class="comment">//必须Type3</span></span><br><span class="line"><span class="comment">//...::reference和pointer                        //必须Type4,5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2019/04/21/STL源码-list/list中traits.png" alt="list中traits"><br>迭代器是泛化指针。对于传递的是类类型名，算法可以通过作用域符::来想iterator提问五种类型。<br>标准库还规定了可以算法可以接受指针参数，此时不能通过作用域直接提问，那该怎么办呢？<br>解决计算机问题的尚方宝剑是：中间层。<br><img src="/2019/04/21/STL源码-list/traits区分指针和类.png" alt="traits区分指针和类"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//偏特化版本</span></span><br><span class="line">(<span class="number">2</span>) <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">3</span>) <span class="keyword">template</span> &lt;calss T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//于是我们可以这样问value_type的内容：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I,...&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(...)</span></span>&#123;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面通过一个声明迭代器，迭代器指向容器和调用算法来具体说明调用过程。<br>list<int> mylist;                                         //声明容器<br>list<int>::iterator itlistbeg = mylist.begin();      //定义两个迭代器<br>list<int>::iterator itlistend = mylist.end();        //<br>distance(itlistbeg,itlistend);                         //调用算法，返回两个迭代器的距离</int></int></int></p><p>(1)产生一个模板类对象mylist，负责存储int型数据，算法与模板类对象没有任何关联。<br>(2)定义两个迭代器itlistbeg和itlistend，类型是模板类实例化之后的一种迭代器类型<br>    在list模板类中这样定义iterator：typedef _list_iterator&lt;T,T&amp;,T<em>&gt; iterator<br>    也就是用_list_iterator&lt;T,T&amp;,T</em>&gt; 定义了迭代器对象。<br>    接着使用list模板类的成员函数begin()和end()为迭代器对象赋值，使其指向这个模板类。<br>(3)使用模板函数distance，会根据实参推断出模板参数类型，在算法内部会将这个类型传递给萃取机<br>    iterator_traits，从而提取出算法需要的5中类型。</p><p>备注:这里typename的作用是这样的：对于iterator_traits<i>::value_type中，编译器并不知道<br>value_type是成员变量还是类型名，我们加上typename是告诉编译器这是一个类型名，避免产生歧义。</i></p><p>我们知道了value_type是怎样通过中间层iterator_traits问答的，下面给出五个问题的完整定义。<br>模板定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line">为了兼容指针的两个偏特化版本</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;I *&gt;&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> I value_type ;</span><br><span class="line"><span class="keyword">typedef</span> ptrdiff difference_type;</span><br><span class="line"><span class="keyword">typedef</span> I* pointer;</span><br><span class="line"><span class="keyword">typedef</span> I&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const I *&gt;&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> I value_type ;</span><br><span class="line"><span class="keyword">typedef</span> ptrdiff difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> I* pointer;</span><br><span class="line"><span class="keyword">typedef</span> consy I&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;list在标准库中被定义成双向链表，接下来我们重点介绍list模板类，list的迭代器&lt;br&gt;和解决算法与迭代器的问答关系的萃取机–iterator_traits。&lt;br&gt;&lt;img src=&quot;/2019/04/21/STL源码-list/list结构.png&quot; alt=&quot;list结构&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="STL" scheme="http://yoursite.com/categories/STL/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>cplusplus三大特性</title>
    <link href="http://yoursite.com/2019/04/19/cplusplus%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/19/cplusplus三大特性/</id>
    <published>2019-04-19T06:41:21.000Z</published>
    <updated>2019-04-19T06:46:55.764Z</updated>
    
    <content type="html"><![CDATA[<p>讲解C++的继承、多态机制。<br><a id="more"></a><br>单继承格式<br>class 类名:继承方式 基类名<br>{<br>派生类新成员；<br>};<br>多继承格式<br>class 类名:继承方式 基类名 继承方式 基类名<br>{</p><p>};<br>继承方式有三种：<br>private ：私有继承，基类中的共有成员和保护成员在子类中均表现为私有成员，不能被派生类的子类访问。<br>           编译器会理解成类型为derived的对象同时也是类型为base的对象，但类型为base的对象不是类型为derived的对象。这点很重要。<br>protected ：保护继承，基类中的共有成员和私有成员均表现为保护成员，可以被派生类成员函数访问和友元函数访问。<br>public ：共有继承，基类的所有成员保留原格式。<br>友元函数不能被继承<br>static成员无论有多少个继承始终就一个，并且访问static用 类名::成员<br>重定义：派生类中与基类同名的函数将覆盖掉基类的函数。<br>多重继承与二义性<br>说明：在多重继承中，若两个或多个类的成员函数有同名的，在派生类调用这个成员函数时如果不指定作用域，就会产生二义性。<br>    class A{<br>    public:<br>        void f();<br>    }</p><pre><code>class B{public:    void f();    void g();}class C:public A,public B{public:    void g();    void h();};</code></pre><p>C c;<br>c.f()就会产生二义性。<br>有三种解决办法<br>法一：调用时指定作用域<br>c.B::f()<br>法二：派生类中同名覆盖<br>    class C:public A,public B{<br>    public:<br>        void g();<br>        void h();<br>        void f()<br>        {<br>            A::f();<br>        }<br>    };<br>法三：虚基类？？？</p><p>C++多态<br>多态可以概括为“一个接口，多种方法”，程序在运行时才决定调用那种方法。C++的多态是通过虚函数来实现的。<br>多态的作用：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。<br>             也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。<br>早绑定：函数的调用，如果在编译期间就知道函数的地址，就是早绑定<br>晚绑定：函数调用的地址不是在编译时知道的而是在运行时确定的。</p><p>这里重点讲解虚函数表：<br>    虚函数表<br>    1、虚函数表是在对象被创建的时候生成的，每一个对象对应一张虚函数表<br>    2、虚函数表中存有对象的所有函数，包括从基类继承的，没有被派生类覆盖的<br>    3、键关系图<br>    至少包含一个纯虚函数的类是抽象类，抽象类不能实例化对象。<br>    接口中不予许含有成员变量，但可以含有静态变量，不可以有构造函数，但一定要有纯虚析构函数<br>    虚函数就可以执行动态绑定。纯虚函数是在虚函数的末尾加入=0;<br>    <img src="/2019/04/19/cplusplus三大特性/虚函数表.png" alt="虚函数表"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解C++的继承、多态机制。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>cplusplus友元</title>
    <link href="http://yoursite.com/2019/04/19/cplusplus%E5%8F%8B%E5%85%83/"/>
    <id>http://yoursite.com/2019/04/19/cplusplus友元/</id>
    <published>2019-04-19T06:38:55.000Z</published>
    <updated>2019-04-19T06:40:12.478Z</updated>
    
    <content type="html"><![CDATA[<p>讲解C++友元在使用时注意事项<br><a id="more"></a><br>友元函数可以访问类的私有成员和保护成员。<br>友元分为友元函数和友元类<br>友元函数：在类中用friend声明，在类外面直接定义，可不用指定类名和friend，友元函数的参数一般会接受一个类对象，用这个类对象访问类中私有成员。</p><p>友元类：在一个类中用friend声明的类叫友元类，整个类的成员函数都是友元函数。</p><pre><code>#include &quot;stdafx.h&quot;#include &lt;iostream&gt;using namespace std;class Box{    double width;public:    friend void printWidth(Box box);//友元函数    friend class BigBox;            //友元类    void setWidth(double wid);};class BigBox{public:    void Print(int width, Box &amp;box)    {        // BigBox是Box的友元类，它可以直接访问Box类的任何成员        box.setWidth(width);        cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt; endl;    }};// 成员函数定义void Box::setWidth(double wid){    width = wid;}// 请注意：printWidth() 不是任何类的成员函数void printWidth(Box box){    /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */    cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt; endl;}// 程序的主函数int main(){    Box box;    BigBox big;    // 使用成员函数设置宽度    box.setWidth(10.0);    // 使用友元函数输出宽度    printWidth(box);    // 使用友元类中的方法设置宽度    big.Print(20, box);    getchar();    return 0;}</code></pre><p>友元函数注意事项：<br>    1、友元函数不是累的成员，所以不能被继承。<br>    2、友元函数可以访问类的成员，但不能访问类的成员函数。<br>    3、一个函数可以是多个类的友元。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解C++友元在使用时注意事项&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>epoll模型学习笔记</title>
    <link href="http://yoursite.com/2019/04/19/epoll%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/19/epoll模型学习笔记/</id>
    <published>2019-04-19T06:34:20.000Z</published>
    <updated>2019-04-19T06:37:48.668Z</updated>
    
    <content type="html"><![CDATA[<p>讲解epoll模型的编程方法，epoll模型的内部原理，以及epoll怎样改进select<br><a id="more"></a><br>epoll模型学习笔记<br>工作方式：<br>LT：缺省方式，同时支持block和no-block socket，在这种做法中，内核告诉我们一个文件描述符是否被就绪了，如果就绪了，你就可以对这个就绪的fd进行IO操作。<br>    如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错的可能性较小。传统的select\poll都是这种模型的代表。<br>ET：高速工作方式，只支持no-block socket。当描述符从未就绪变为就绪态时，内核通过epoll告诉你。然后他就假设你知道文件描述符已经就绪，不再为这个描述符<br>    提供更多就需通知。直到你做了某些操作使得那个文件描述符不再就绪。<br>区别：LT事件不会丢弃，只要读buffer中有数据可以读取，就不断的通知你。而ET只有在事件发生时才通知。</p><p>使用方式<br>//创建一个epoll句柄，size告诉内核监听的数目<br>    1、int epoll_create(int size)<br>//epoll事件注册函数<br>    2、epoll_ctl(int epfd,int op,int fd,struct epoll_event<em> event)<br>　　参数epfd为epoll的句柄；<br>　　参数op表示动作，用3个宏来表示：EPOLL_CTL_ADD(注册新的fd到epfd)，EPOLL_CTL_MOD(修改已经注册的fd的监听事件)，EPOLL_CTL_DEL(从epfd删除一个fd)；<br>　　参数fd为需要监听的标示符；<br>　　参数event告诉内核需要监听的事件,event结构<br>    struct epoll_event{<br>        _uint32_t events;<br>        epoll_data data;<br>    };<br>   typedef union epoll_data {<br>       void        </em>ptr;<br>       int          fd;<br>       uint32_t     u32;<br>       uint64_t     u64;<br>    }epoll_data_t;</p><pre><code>events可以用以下几个宏： EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</code></pre><p>　　EPOLLOUT：表示对应的文件描述符可以写<br>　　EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）<br>　　EPOLLERR：表示对应的文件描述符发生错误<br>　　EPOLLHUP：表示对应的文件描述符被挂断；<br>　　EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的<br>　　EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里<br>//等待事件发生，类似select调用。<br>    3、int epoll_wait(int epfd,struct epoll_event* events,int maxevents,int timeout)<br>    events: 表示从内核得到事件的集合<br>    maxevents: 告知内核这个events有多大，它不能大于epoll_create的size。<br>    timeout：超时时间(ms)(0立即返回，-1永久等待)<br>    返回值：需要处理的事件数目，0代表超时，-1代表失败。</p><p>Select、poll和epoll的对比：<br>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024。<br>epoll的实现机制：<br>（1）调用epoll_create时，做了以下事情：<br>内核帮我们在epoll文件系统里建了个file结点；<br>在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket；<br>建立一个list链表，用于存储准备就绪的事件。<br>（2）调用epoll_ctl时，做了以下事情：<br>把socket放到epoll文件系统里file对象对应的红黑树上；<br>给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。<br>（3）调用epoll_wait时，做了以下事情：<br>观察list链表里有没有数据。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已。<br>即：<br>一颗红黑树，一张准备就绪句柄链表，少量的内核cache，解决了大并发下的socket处理问题。<br>执行epoll_create时，创建了红黑树和就绪链表；<br>执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据;<br>执行epoll_wait时立刻返回准备就绪链表里的数据即可。<br>epoll解决了上述三个特点<br>（1）对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。<br>（2）对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解epoll模型的编程方法，epoll模型的内部原理，以及epoll怎样改进select&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://yoursite.com/2019/04/19/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/19/散列表/</id>
    <published>2019-04-19T01:42:32.000Z</published>
    <updated>2019-04-20T03:50:43.505Z</updated>
    
    <content type="html"><![CDATA[<p>讲解散列表的<br><a id="more"></a><br>散列表最适合的求解问题是查找与给定值相等的记录，不适合做范围查找，不适合进行排序和求最大最小值。<br>同义词：如果两个关键字的散列函数值相等，称两个关键字为同义词。<br>散列函数构造方法：<br>线性函数<br>抽取：从关键字中抽取一部分作为散列位置的方法。比如以电话号码电话号码的最后四位。<br>折叠法：<br>余数法：<br>随机数法：<br>处理散列冲突的方法：<br>1、开放定址法：fi(key)=(f(key)+di)%m   (di=1,2,3,4,5…m-1)  这里的di从1开始依次增加。<br>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。<br>沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）<br>为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到<br>开放的地址则表明表中无待查的关键字，即查找失败。<br>2、在散列函数：事先准备多个散列函数。<br>3、连地址法：将所有关键字为同义词的记录存储在单链表中，在散列表中只存储链表的头结点。<br>4、公共溢出区：把所有冲突的关键词找一个公共溢出区。适用于同义词较少的情况。</p><p>代码实现<br>一、开放定址法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY 65536</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;elem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            H-&gt;elem[i] = NULLKEY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash function,the function can be changeable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[addr] != NULLKEY)        <span class="comment">//open addressing</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;</span><br><span class="line">    H-&gt;elem[addr] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[*addr] != key)</span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;elem[*addr] == NULLKEY || *addr == Hash(key))</span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    InitHashTable(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> elem[<span class="number">12</span>] = &#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(h,elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h-&gt;elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SearchHash(h,h-&gt;elem[i],&amp;addr) == SUCCESS)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,addr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二、链地址法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY 65536</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hashnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;HashNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HashNode *head[HASHSIZE];</span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            H-&gt;head[i] = (HashNode *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(HashNode));</span><br><span class="line">            H-&gt;head[i]-&gt;data = NULLKEY;</span><br><span class="line">            H-&gt;head[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash function,the function can be changeable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key);</span><br><span class="line">    HashNode *node = (HashNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashNode));</span><br><span class="line">    HashNode *tmp = H-&gt;head[addr]-&gt;next;</span><br><span class="line"></span><br><span class="line">    node-&gt;data = key;</span><br><span class="line">    node-&gt;next = tmp;</span><br><span class="line"></span><br><span class="line">    H-&gt;head[addr]-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashNode *tmp;</span><br><span class="line">    *addr = Hash(key);</span><br><span class="line"></span><br><span class="line">        tmp = H-&gt;head[*addr]-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;data == key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"find the key\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">    HashNode *tmp;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    InitHashTable(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> elem[<span class="number">12</span>] = &#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(h,elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = h-&gt;head[i]-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tmp-&gt;data);</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SearchHash(h,elem[i],&amp;addr) == SUCCESS)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,addr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解散列表的&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://yoursite.com/2019/04/18/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/18/平衡二叉树/</id>
    <published>2019-04-18T13:16:40.000Z</published>
    <updated>2019-04-19T01:16:26.005Z</updated>
    
    <content type="html"><![CDATA[<p>讲解平衡二叉树的定义，相关术语，<br><a id="more"></a><br>定义：是一种平衡二叉树，其中每个节点的左子树和右子树的高度差不大于1.<br>相关术语：<br>平衡因子：二叉树上节点的左子树的高度减去右子树的高度的差值称为平衡因子。<br>最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树。<br>左旋：右孩子的左结点，如果右孩子存在左结点，需要先把他调整为根结点的右结点，然后再追加右孩子的左结点。<br>右旋：左孩子的右结点，如果左孩子存在右结点，需要先把他调整成根节点的左结点，然后再追加左孩子的右结点。<br>构建思想：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因为插入而破坏了树的平衡性，若是，则找出最小不平衡子树，进行相应的旋转，使之成为新的平衡子树。<br>          对于最小不平衡子树根结点BF与它子树的BF符号相反时，说明子树现在的结构与要旋转方向不一至，必须先调整子树结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解平衡二叉树的定义，相关术语，&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="pragrom" scheme="http://yoursite.com/categories/pragrom/"/>
    
    
  </entry>
  
  <entry>
    <title>freeBSD学习笔记</title>
    <link href="http://yoursite.com/2019/04/18/freeBSD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/18/freeBSD学习笔记/</id>
    <published>2019-04-18T07:44:12.000Z</published>
    <updated>2019-04-18T08:25:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>Linux各种混乱 不堪的发行版相比，FreeBSD只有唯一的版本，同时，FreeBSD关注的是操作系统的稳定性、性能和品质，适合作为服务器的操作系统。<br><a id="more"></a><br>三个主流的linux发行版：Red Hat、Mandrake和SUSE。每一个Linux发行版本都存在一些差异，而它们之间最大的差异则在于文件系统的结构。</p><p>FreeBSD使用“包”来安装、卸载和升级应用程序。‘pkg_add’命令被用于安装一个你手工下载到计算机的包。你也可以用‘-r’开关来让 它自动的从<br>Internet获取，当然，也包括这个包所依赖的一切。FreeBSD包的真正美妙之处在于“连接点”(Ports)树。连接点树是 ——FreeBSD包含的应用程序<br>之间的继承关系。每一个文件夹都包含Makefile，以及让特定应用程序能够在FreeBSD上正确运行所需要的补丁。例如，如果我想安装<br>Apache web服务器，我所需要做的只是cd到/usr/ports/www/apache文件夹，然后运行‘make &amp;&amp; make install’，然后去小吃售卖机前。<br>如果我拥有一台速度够快的电脑，同时拥有一个足够大方的Internet连接，当我回来的时候Apache源代码 的下载、补丁、编译和安装<br>肯定都已经做完了。连接点树也能够处理Apache运行依赖的那些程序，无论我用连接点树安装、手工编译，还是通过安装已经编译<br>好的二进制包。连接点树能够通过$PATH找到它需要的东西。<br>Linux和FreeBSD的另一个区别在于，对于FreeBSD而言，你安装的连接点或者包99%都会被放到/usr/local，而在 Linux上有时是/usr，<br>有时是/opt。这可能只是一个很小的区别，但你至少可以知道你的程序安装到了/usr/local，而不是扩散到了文件系 统的各个地方。</p><p>FreeBSD系统使用cvsup来保持它是最新的。一旦你建立了‘sup-file’，cvsup将会把你本地的系统和cvsup服务器上的进行比较，并且下载那些修改过的东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux各种混乱 不堪的发行版相比，FreeBSD只有唯一的版本，同时，FreeBSD关注的是操作系统的稳定性、性能和品质，适合作为服务器的操作系统。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="freeBSD" scheme="http://yoursite.com/categories/freeBSD/"/>
    
    
  </entry>
  
  <entry>
    <title>sed指令</title>
    <link href="http://yoursite.com/2019/04/17/sed%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/17/sed指令/</id>
    <published>2019-04-17T04:26:54.000Z</published>
    <updated>2019-04-21T16:36:05.044Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题来源于怎样通过shell指令查找、替换多个文件中的某字符串<br><a id="more"></a><br>vim在编译模式下进行多文件查找与替换</p><p>替换<br>在一个文件中在vim的编辑模式下这样替换：<br>:25,52s/addr/abcdefg/cg     #将文件中addr替换成abcdefg，c：每次替换会询问，g：全部替换<br>sed指令介绍<br>sed指令把处理的行存入临时缓冲区中，接着用sed指令处理缓冲区的内容，处理完之后把缓冲区的内容送到屏幕<br>但是文件中的内容并没有改变，如果想改变文件中的内容，可以用参数i<br>格式：<br>1、sed [options] ‘指令’ files<br>2、sed [options] -f 脚本 files<br>其中’指令’处可以是正则表达式，正则表达式用/…/分隔<br>替换：<br>1、sed ’s/book/books/‘ files         # s 替换<br>2、sed -n ‘s/book/books/p’ files     # -n -p 结合只用于输出改变的行<br>3、sed ‘s/book/books/g’    files     # g：全部替换<br>4、sed ’s/book/books/ng’   files     # 从n处开始替换<br>5、sed -i ‘s/book/books/g’  files    # 直接编辑文本<br>6、sed -i ‘s/$/abcdefh/g’ files      # 每行的末尾加入abcdefh<br>7、sed -i ‘s/\&lt;num>/nums/g’ taccumulate.cpp   # 仅仅匹配num,不匹配numss这样的单词。<br>删除：<br>删除空白行：sed -i ‘/^$/d’ files<br>删除第n行： sed -i ‘/4/d’ files<br>指定删除范围： sed -i ‘2,$/d’ files<br>删除最后一行： sed -i ‘$/d’ files<br>删除文件所有以test开头的行：sed ‘/^test/d’ files</p><p>多个sed组合<br>sed ‘表达式’ | sed ‘表达式’</p><p>-e选项，允许在同一条指令中执行多条语句<br>例如：sed -e ‘1,5d’ -e ‘s/test/abcdef/g’ files<br>第一条语句会对第二条造成影响</p><p>选定行的范围<br>sed -n ‘/test/,/check/p’ files<br>例如：sed -n ‘/5,/^test/p’ files<br>w:写入文件指令(这条指令完全可以用重定向解决)<br>sed -n ‘/test/w file’ example     # 在example中所有包含test的行都被写入到file中，且file被清空</p><p>a\命令 行后添加一行<br>sed ‘/return/this is a line’ client.cpp    # 在client.cpp中包含return的行后面添加this is a line<br>i\命令 行前添加<br>sed ‘/2i\’this is a line’ client.cpp</p><p>注意：<br>1、sed默认使用单引号来引用，但是表达式内部包含变量字符串是，需要用双引号<br>    test=hello<br>    echo hello WORLD | sed “s/$test/HELLO</p><p>awk指令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个问题来源于怎样通过shell指令查找、替换多个文件中的某字符串&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>int,size_t,ssize_t的区别</title>
    <link href="http://yoursite.com/2019/04/11/int-size-t-ssize-t%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/04/11/int-size-t-ssize-t的区别/</id>
    <published>2019-04-11T15:27:22.000Z</published>
    <updated>2019-04-11T16:07:57.248Z</updated>
    
    <content type="html"><![CDATA[<p>讲述int,size_t,ssize_t的区别<br><a id="more"></a><br>科普一下：<br>    32位机器与64位机器是指通用寄存器的长度，代表一次可以处理的数据长度，并不是地址总线的数量。<br>    32位机器，内存空间为4G，所以地址总线最少为32位<br>    64位机器，地址总线一般在40位左右。<br>    地址总线过多，内存位数过多，处理起来很麻烦。</p><p>一、int<br>    int在32位与64位机器上都是32位。32位的大小范围是[-2^31~2^31] 大约等于[-10^9~10^9)<br>二、size_t<br>    size_t这个类型足以表示这台机器上的任何数据的大小。并且一定是unsigned类型。<br>    对于32位机器，size_t是unsigned int，<br>    对于64位机器，size_t是unsigned long 或 unsigned long long<br>三、ssize_t<br>    ssize_t与size_t一样，这个类型足以表示这台机器上的任何数据的大小，只是这个类型一定是signed类型。<br>    对于32位机器，size_t是signed int，<br>    对于64位机器，size_t是signed long 或 signed long long </p><p>下面看一段官方解释<br>&lt;%codeblock%&gt;<br>     This’s a way of defining size_t and ssize_t in Linux:</p><pre><code> //&quot;linux/types.h&quot; typedef __kernel_size_t size_t; typedef __kernel_ssize_t ssize_t; //&quot;asm/posix_types.h&quot;typedef unsigned int __kernel_size_t; typedef int __kernel_ssize_t; It seems so tricky to me. What benefits do we get from such a tricky typedef ? better name (size_t is shorter than unsigned int) ?[/color]On some 64-bit platforms, &apos;int&apos; and &apos;unsigned int&apos; may be 32-bits,while addresses and even memory sizes could require 64 bits(e.g. for the size of an allocated memory block &gt; 4GB).On such platforms, size_t could be typedef&apos;d to a differenttype, such as &apos;unsigned long long&apos;.Note also that &apos;size_t&apos; is a typedef required by the ISO C standard(it must be available if &lt;stddef.h&gt; is included). However, &apos;ssize_t&apos;does not exist in the C standard -- the standard &apos;ptrdiff_t&apos;typedef is nearly equivalent.</code></pre><p>&lt;%endcodeblock%&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述int,size_t,ssize_t的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>工厂类</title>
    <link href="http://yoursite.com/2019/04/08/%E5%B7%A5%E5%8E%82%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/04/08/工厂类/</id>
    <published>2019-04-08T14:37:49.000Z</published>
    <updated>2019-04-08T14:42:28.616Z</updated>
    
    <content type="html"><![CDATA[<p>讲述设计模式之简单工厂类<br><a id="more"></a><br>工厂模式：<br>    简单工厂模式可以理解为负责生产对象的一个类，称为”工厂类”<br>模式原理：<br>![模式组成(工厂类/模式组成.png)]<br>使用步骤：<br>    创建抽象产品类 &amp; 定义具体产品的公共接口；<br>    创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>    创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；<br>    外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例</p><p>使用例子：<br>背景：小成有一个塑料生产厂，用来做塑料加工生意<br>目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：创建抽象产品类：</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    public <span class="keyword">abstract</span> void <span class="type">Show</span>();</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">2</span>：创建具体产品类(继承抽象产品类)，定义生产的具体产品</span><br><span class="line"><span class="comment">//具体产品类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductA</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductB</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductC</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">3</span>：创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类实例。</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    public static <span class="type">Product</span> <span class="type">Manufacture</span>(<span class="type">String</span> <span class="type">ProductName</span>)&#123;</span><br><span class="line"><span class="comment">//工厂类里用switch语句控制生产哪种商品；</span></span><br><span class="line"><span class="comment">//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。</span></span><br><span class="line">        switch (<span class="type">ProductName</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductA</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductB</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductC</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">4</span>：外部调用工厂类</span><br><span class="line"><span class="comment">//工厂产品生产流程</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryPattern</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">Factory</span> mFactory = <span class="keyword">new</span> <span class="type">Factory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//调用工厂类的静态方法 &amp; 传入不同参数从而创建产品实例</span></span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"A"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"B"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品C</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"C"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品D</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"D"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述设计模式之简单工厂类&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>linux服务器开发常用四条指令</title>
    <link href="http://yoursite.com/2019/04/06/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%9B%9B%E6%9D%A1%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/06/linux服务器开发常用四条指令/</id>
    <published>2019-04-06T15:38:19.000Z</published>
    <updated>2019-04-22T13:33:57.313Z</updated>
    
    <content type="html"><![CDATA[<p>讲述linux服务器开发4条指令<br><a id="more"></a><br>一、ipcs指令-提供进程间通信方式的信息<br>    ipcs -a 列出所有进程间通信方式的信息<br>    ipcs -m 列出共享内存信息<br>    ipcs -q 列出消息队列信息<br>    ipcs -s 列出信号量信息<br>    ipcs -t 列出更改时间<br>    ipcs -c 列出IPC方式的创建者和拥有者<br>    ipcs -c 列出ipc各种方式的在该系统下的限制条件信息<br>二、ipcrm指令-移除一个消息对象。或者共享内存段，或者一个信号集<br>    参数是由规律的：接大写/小写 M,Q,S代表移除的类型。大写代表按照key值移除。小写代表按照id移除。<br>    例如：ipcrm -M shnkey值 # 移除键值为shnkey的共享内存<br>三、netstat指令：用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。<br>    -a (all)显示所有选项，默认不显示LISTEN相关<br>    -t (tcp)仅显示tcp相关选项<br>    -u (udp)仅显示udp相关选项<br>    -n 拒绝显示别名，能显示数字的全部转化成数字。<br>    -l 仅列出有在 Listen (监听) 的服務状态<br>    -p 显示建立相关链接的程序名<br>    -r 显示路由信息，路由表<br>    -e 显示扩展信息，例如uid等<br>    -s 按各个协议进行统计<br>    -c 每隔一个固定时间，执行该netstat命令。<br>    指令组合举例：<br>    netstat -nat | grep “192.168.1.15:22” |awk ‘{print $5}’|awk -F: ‘{print $1}’|sort|uniq -c|sort -nr|head -20<br>四、tcpdump指令:  tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息<br>    tcpdump -D 获取网络适配器列表<br>    tcpdump -i &lt;网络适配器编号&gt;  指定监控哪个网络适配器<br>    tcp -i 2 host 192.168.1.199 and tcp port 8088     指定监控有线网卡ip地址为192.168.1.199上端口号为8088的TCP协议。<br>    tcpdump -X -i 2 host 172.16.86.111 and tcp port 443     捕获数据包header部分。<br>    tcpdump -X -s 0 -i 2 host 172.16.86.111 and tcp port 443   -s后面加长度数据，0表示自动设置长度使其能显示所有数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述linux服务器开发4条指令&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>子网掩码与网关</title>
    <link href="http://yoursite.com/2019/04/05/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%B8%8E%E7%BD%91%E5%85%B3/"/>
    <id>http://yoursite.com/2019/04/05/子网掩码与网关/</id>
    <published>2019-04-05T12:35:19.000Z</published>
    <updated>2019-04-05T12:38:50.546Z</updated>
    
    <content type="html"><![CDATA[<p>以下我们就来深入浅出地讲解什么是子网掩码。<br><a id="more"></a><br>一、IP地址的结构<br>    要想理解什么是子网掩码，就不能不了解IP地址的构成。互联网是由许多小型网络构成的，每个网络上都有许多主机，<br>    这样便构成了一个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络号和主机号两部分，<br>    以便于IP地址的寻址操作。IP地址的网络号和主机号各是多少位呢？如果不指定，就不知道哪些位是网络号、哪些是主机号，<br>    这就需要通过子网掩码来实现。<br>    对于这样的结构ip/1-32，代表子网掩码中网络号的长度<br>    192.168.1.1/24，网络号长度为24</p><p>二、什么是子网掩码<br>    子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。<br>    子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。</p><p>三、三类IP地址<br>    划分A,B,C三类子网的方式是根据IP地址的第一段信息<br>    A类IP地址：1-126<br>    B类IP地址：128-191<br>    C类IP地址：192-155</p><p>四、网络地址与广播地址<br>    网络地址：IP地址与子网掩码&amp;的结果<br>    广播地址：下一个网段的网络地址-1</p><p>五、网关地址<br>    要实现两个子网之间的通信，必须使用网关。比如A网络向B网络发送数据。A网络的主机发现目的主机不在本局域网内，<br>    就将数据发送到自己的网关，再转发到B网络的网关，再有B网络的网关B发送到次局域网中的目的主机。</p><p>再根据CCNA中会出现的题目给大家举个例子：<br>首先，我们看一个考试中常见的题型：一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址。<br>常规办法是把这个主机地址和子网掩码都换算成二进制数，两者进行逻辑与运算后即可得到网络地址。<br>其实大家只要仔细想想，可以得到另一个方法：255.255.255.224的掩码所容纳的IP地址有256－224＝32个（包括网络地址和广播地址），<br>那么具有这种掩码的网络地址一定是32的倍数。而网络地址是子网IP地址的开始，广播地址是结束，可使用的主机地址在这个范围内，<br>因此略小于137而又是32的倍数的只有128，所以得出网络地址是202.112.14.128。而广播地址就是下一个网络的网络地址减1。而下一个32的倍数是160，<br>因此可以得到广播地址为202.112.14.159。</p><p>子网络 2进制子网络域数 2进制主机域数的范围 2进制主机域数的范围<br>第1个子网络 000 00000 thru 11111 .0 thru.31<br>第2个子网络 001 00000 thru 11111 .32 thru.63<br>第3个子网络 010 00000 thru 11111 .64 thru.95<br>第4个子网络 011 00000 thru 11111 .96 thru.127<br>第5个子网络 100 00000 thru 11111 .128 thru.159<br>第6个子网络 101 00000 thru 11111 .160 thru.191<br>第7个子网络 110 00000 thru 11111 .192 thru.223<br>第8个子网络 111 00000 thru 11111 .124 thru.255 </p><p>CCNA考试中，还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。比如一个子网有10台主机，那么对于这个子网需要的IP地址是：<br>10＋1＋1＋1＝13<br>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。因为13小于16（16等于2的4次方），所以主机位为4位。而<br>256－16＝240<br>所以该子网掩码为255.255.255.240。<br>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为：<br>14＋1＋1＋1＝17<br>17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下我们就来深入浅出地讲解什么是子网掩码。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>shell指令</title>
    <link href="http://yoursite.com/2019/04/04/shell%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/04/shell指令/</id>
    <published>2019-04-04T14:50:28.000Z</published>
    <updated>2019-04-04T14:55:04.963Z</updated>
    
    <content type="html"><![CDATA[<p>讲述shell编程中的常用命令：apt<br><a id="more"></a><br>一、apt指令<br>    apt-cache search # ——(package 搜索包)<br>    apt-cache show #——(package 获取包的相关信息，如说明、大小、版本等)<br>    sudo apt-get install # ——(package 安装包)sudo apt-get install # —–(package - - reinstall 重新安装包)<br>    sudo apt-get -f install # —–(强制安装?#”-f = –fix-missing”当是修复安装吧…)<br>    sudo apt-get remove #—–(package 删除包)<br>    sudo apt-get remove - - purge # ——(package 删除包，包括删除配置文件等)<br>    sudo apt-get autoremove –purge # —-(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)<br>    sudo apt-get update #——更新源<br>    sudo apt-get upgrade #——更新已安装的包<br>    sudo apt-get dist-upgrade # ———升级系统<br>    sudo apt-get dselect-upgrade #——使用 dselect 升级<br>    apt-cache depends #——-(package 了解使用依赖)<br>    apt-cache rdepends # ——(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧…)<br>    sudo apt-get build-dep # ——(package 安装相关的编译环境)<br>    apt-get source #——(package 下载该包的源代码)<br>    sudo apt-get clean &amp;&amp; sudo apt-get autoclean # ——–清理下载文件的存档 &amp;&amp; 只清理过时的包<br>    sudo apt-get check #——-检查是否有损坏的依赖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述shell编程中的常用命令：apt&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>51单片机RAM与ROM</title>
    <link href="http://yoursite.com/2019/04/04/51%E5%8D%95%E7%89%87%E6%9C%BARAM%E4%B8%8EROM/"/>
    <id>http://yoursite.com/2019/04/04/51单片机RAM与ROM/</id>
    <published>2019-04-04T00:33:42.000Z</published>
    <updated>2019-04-04T01:26:15.823Z</updated>
    
    <content type="html"><![CDATA[<p>讲述51单片机的内存分配形式，进而想清楚单片机程序执行的流程。<br><a id="more"></a><br>51单片机在物理结构上有4个存储空间：<br>1、片内数据存储器<br>2、片外数据存储器<br>3、片内程序存储器<br>4、片外程序存储器<br>对于用户而言，只有三个，片内外统一寻址的程序存储器(MOVC),片内数据存储器(MOV),片外数据存储器(MOVX).<br>51单片机支持64kROM和64kRAM</p><p>程序存储器：<br>    4kROM在片内，此时EA置1即可。再使用片外ROM时，需要将EA接地，POSN接片外ROM的片选信号。当=1时，程序从片内ROM开始执行，当PC值超过片内ROM容量时会自动转向外部ROM空间。<br>    ROM存储结构是：<br>    0000H —— 系统复位，PC指向此处；<br>    0003H —— 外部中断0入口<br>    000BH —— T0溢出中断入口<br>    0013H —— 外中断1入口<br>    001BH —— T1溢出中断入口<br>    0023H —— 串口中断入口<br>    002BH —— T2溢出中断入口<br>    0033H —— 用户ROM<br>    <img src="/2019/04/04/51单片机RAM与ROM/ROM结构.png" alt="ROM结构"><br>数据存取器(RAM)：<br>    物理上分为两大区：00H ~ 7FH即128B内RAM 和 SFR区。<br>    <img src="/2019/04/04/51单片机RAM与ROM/片内RAM.png" alt="片内RAM"><br>51单片机支持的寻址方式：<br>    立即数寻址：立即数寻址又称立即寻址，即指令中直接给出操作数的寻址方式称为立即数寻址。在51系列单片机指令系统中，立即数用前面加“#”号的8位数表示（#data，如#30H）或16位数（#data16，如#2052H）表示。举例说明立即数寻址方式，以传送指令为例。<br>    例：MOV A, #80H ；80H——&gt;A<br>    MOV DPTR, #2000H ；2000H——&gt;DPTR<br>    直接寻址：指令中直接给出操作数地址（dir）的寻址方式称为直接寻址。寻址对象为：1 内部数据存储器，在指令中以直接地址表示；2特殊功能寄存器SFR，在指令中用寄存器名称表示。<br>    例：MOV A, 25H ；内部RAM的（25H）——&gt;A<br>    MOV P0, #45H ；45H——&gt;P0 ,P0为直接寻址的SFR<br>    MOV 30H，20H ；内部RAM的（20H）——&gt;（30H）<br>    寄存器寻址：以通用寄存器的内容为操作数的寻址方式称为寄存器寻址。通用寄存器包括：A、B、DPTR、R0～R7。其中B寄存器仅在乘法、除法指令中为寄存器寻址，在其它指令中为直接寻址。A寄存器可以寄存器寻址，又可以直接寻址（此时写作ACC）。直接寻址和寄存器寻址的差别在于，直接寻址是操作数所在的字节地址（占一个字节），寄存器寻址是寄存器编码出现在指令码中。寄存器寻址速度比直接寻址要快。除上面所指的几个寄存器外，其它特殊功能寄存器一律为直接寻址。<br>    例：MOV A, R0 ；R0——&gt;A，R0为寄存器寻址<br>    MUL AB ；A×B——&gt;BA，A，B为寄存器寻址<br>    MOV B, R0 ；R0——&gt;B，R0为寄存器寻址，B为直接寻址<br>    PUSH ACC ；A的内容入栈，A为直接寻址<br>    ADD A, ACC ；A为寄存器寻址，ACC为直接寻址<br>    寄存器间接寻址：以寄存器中的内容为地址，该地址的内容为操作数的寻址方式称为寄存器间接寻址。能够进行寄存器间接寻址的寄存器有：R0、R1、DPTR，用前面加@表示，如@R0、@R1、@DPTR。寄存器间接寻址的存储空间包括内部数据存储器和外部数据存储器。由于内部数据存储器共有128字节，因此用一字节的R0和R1可间接寻址整个空间。而外部数据存储器最大可达64K，仅R0或R1无法寻址整个空间，为此需要由P2端口提供外部RAM高8位地址，由R0或R1提供低8位地址，由此共同寻址64K字节范围。也可用16位的DPTR寄存器间接寻址64K字节存储空间。在指令中，是对内部RAM还是对外部RAM寻址，区别在于对外部RAM的操作仅有数据传送指令，并且用MOVX作为操作助记符。<br>    例：MOV @R0, A ；A——&gt;以R0内容为地址的内部RAM中<br>    MOVX @DPTR, A ；A——&gt;以DPTR内容为地址的外部RAM中<br>    变址寻址：由寄存器DPTR或PC中的内容加上A累加器内容之和而形成操作数地址的寻址方式称为变址寻址。变址寻址只能对程序存储器中的数据进行寻址操作。由于程序存储器是只读存贮器，因此变址寻址只有读操作而无写操作。在指令符号上采用MOVC的形式。<br>    例：MOVC A, @A+DPTR ；（A+DPTR）——&gt;A<br>    MOVC A, @A+PC ； （PC）+1——PC （（A）+（PC））——&gt;A<br>    位寻址：对位地址中的内容进行位操作的寻址方式称为位寻址。由于单片机中只有内部RAM和特殊功能寄存器的部分单元有位地址，因此位寻址只能对有位地址的这两个空间进行寻址操作。位寻址是一种直接寻址方式，由指令给出直接位地址。与直接寻址不同的是，位寻址只给出位地址，而不是字节地址。<br>    例：SETB 20H ；1——&gt;20H位<br>    MOV 32H, C ；进位Cy（即指令中的C）——&gt;32H位<br>    相对寻址：以当前程序计数器PC的内容为基址，加上指令给出的一字节补码数（偏移量）形成新的PC值的寻址方式称为相对寻址。相对寻址方式只修改PC值，故主要用于实现程序的分支转移。<br>    例：SJMP 08H ；PC+2+08H——&gt;PC （该指令为两字节，所以有PC+2）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述51单片机的内存分配形式，进而想清楚单片机程序执行的流程。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="chips" scheme="http://yoursite.com/tags/chips/"/>
    
  </entry>
  
  <entry>
    <title>滑动串口、OOD数据</title>
    <link href="http://yoursite.com/2019/04/03/%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/04/03/协议/</id>
    <published>2019-04-03T05:47:13.000Z</published>
    <updated>2019-04-22T08:56:17.088Z</updated>
    
    <content type="html"><![CDATA[<p>记录TCP滑动窗口，带外数据和缓冲区<br><a id="more"></a><br>一、带外数据：OOB数据是是传输协议层使用的out of data(带外数据)，来发送一些重要数据。一般不使用与数据相同的通道，而是使用特殊的通道，使得数据不容易被阻塞。TCP协议没有所谓的带外数据，而是使用一种紧急模式：设置URG位为1。在程序中，接受OOB数据将recv中的flag为设置成MSG_OOB（windows），发送OOB数据将send的flag设置成MSG_OOB即可。      </p><p>二、缓冲区<br><img src="/2019/04/03/协议/缓冲区.png" alt="缓冲区"><br>当没有调用recv时，内核接受缓冲区的数据一致存在。<br>由于TCP发送完数据之后需要应答ACK，一致等待应答很浪费时间，此时需要滑动窗口。<br>三、滑动窗口<br><img src="/2019/04/03/协议/滑动窗口1.png" alt="滑动窗口1"><br>在窗口内的数据：#2，#3。已经发送但还未应答的数据段32-45.TCP会分成四段发送出去：s1,s2,s3,s4。如果已经收到s1，s2，s4但未收到s3。此时接受端发送应答。此时窗口会右移到s3处。为了保证传输顺序。此时TCP等待一段时间之后会重传（重传机制），重传成功后，s3,s4被遗弃确认。不成功s4被丢弃。<br>流量控制：<br>超时重传机制：见上面。<br>累计ACK：TCP并不是对被一个报文段都会ACK，可能会两个报文一起ACK。<br><img src="/2019/04/03/协议/滑动窗口2.png" alt="滑动窗口2"><br>TCP总是告知对端在任何时刻它一次能从对端接受多少字节，者称为滑动窗口。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录TCP滑动窗口，带外数据和缓冲区&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>C语言DLL文件产生和调用</title>
    <link href="http://yoursite.com/2019/04/03/C%E8%AF%AD%E8%A8%80DLL%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E5%92%8C%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/03/C语言DLL文件产生和调用/</id>
    <published>2019-04-03T05:33:33.000Z</published>
    <updated>2019-04-04T00:44:09.645Z</updated>
    
    <content type="html"><![CDATA[<p>讲述C/C++产生的DLL文件怎样被C++或C#调用<br><a id="more"></a><br>创建DLL文件，选择win32项目，选择生成DLL<br><img src="/2019/04/03/C语言DLL文件产生和调用/创建.png" alt="创建"><br>添加头文件和.c文件<br>头文件中的声明<br><img src="/2019/04/03/C语言DLL文件产生和调用/声明.png" alt="声明"><br>.c文件中可以定义中间函数，这个中间函数可一直任何普通函数。然后导出函数一定要加<br>_stdcall 并且导出函数一定是要在头文件中用_declsped声明的。<br><img src="/2019/04/03/C语言DLL文件产生和调用/导出.png" alt="导出"><br>3.添加模块文件.def。<br>4.点击生成解决方案就产生了DLL。</p><p>二、C#调用DLL的方法<br>  包含运行时库<br>using System.Runtime.InteropServices;//运行时库<br>将DLL拷贝到根目录<br>导出语法如下：<br><img src="/2019/04/03/C语言DLL文件产生和调用/Csharp导入.png" alt="Csharp导入"><br>4.Area就是一个在C#中直接调用的成员方法。<br>详细网址<br><a href="https://blog.csdn.net/C_xxy/article/details/78998758" target="_blank" rel="noopener">https://blog.csdn.net/C_xxy/article/details/78998758</a></p><p>三、C++调用DLL的方法<br>1、加载DLL库<br>    HINSTANCE hinstLib = LoadLibrary(TEXT(“ytr.dll”));<br>2、声明函数指针<br>    typedef int (__stdcall *MYPROC)(LPWSTR,LPWSTR);<br>    MYPROC ProcAdd;<br>3、函数指针赋值<br>    ProcAdd = (MYPROC)GetProcAddress(hinstLib,”FB_Open”);<br>4、函数指针调用函数<br>    ProcAdd(3,”abc”)    //两个参数的函数指针调用过程<br>5、释放DLL<br>    BOOL fFreeResult = FreeLibrary(hinstLib);<br>用VS查看DLL是多少位的，这里需要注意64为的应用程序不能调用32 为DLL，32 为应用程序也不能调用64为DLL。<br><img src="/2019/04/03/C语言DLL文件产生和调用/查看.png" alt="查看"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述C/C++产生的DLL文件怎样被C++或C#调用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>再读STM32笔记</title>
    <link href="http://yoursite.com/2019/04/03/%E5%86%8D%E8%AF%BBSTM32%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/03/再读STM32笔记/</id>
    <published>2019-04-03T05:25:24.000Z</published>
    <updated>2019-04-03T06:05:39.620Z</updated>
    
    <content type="html"><![CDATA[<p>这些天将STM32的正点原子的历程调了一遍，收获还真不少，为了方便自己理解，现在从接口，编程思路，ARM结构，外设，LWIP，UCOSIII几部分进行一下总结。<br><a id="more"></a><br>一、接口，先了解的接口有：<br>SCCB–DCMI—数字摄像头接口<br>SAI—串行音频接口<br>SDIO—安全数字输入输出接口<br>LTCD—RGB显示屏接口<br>FMC—扩展外部RAM接口<br>二、ARM结构<br>cotexM4CPU的共分7个block，每个block=512M。block3、4、5、6为FMC连接的外部存储器。block0包含flash memory=1M为用户程序存储器。64k的CCMRAM。block1包含还包含192k的SRAM。block2为APB1,2与AHB1,2连接的外设。这些外设当然就是那些接口。cotexM4采用总线矩阵的形式管理取址，取数据，执行的过程。<br><img src="/2019/04/03/再读STM32笔记/总线结构.png" alt="总线结构"><br>由于这种单片机的功能太多，一个引脚对应一种功能太浪费资源。出现了重映射与复用。重映射也就是说一个外设可能对应多种引脚，比如UART0_RX可以和4个引脚对应，这是就可以用重映射到其他引脚。复用就是用来一个引脚的第二三功能。开启复用功能时不需要把一个外设的所有引都打开，只需要打开一个引脚的复用功能就好。<br><img src="/2019/04/03/再读STM32笔记/引脚复用.png" alt="引脚复用"><br>在线升级应用程序IAP<br><img src="/2019/04/03/再读STM32笔记/IAP.png" alt="IAP"><br>中断管理这里先不说，在线升级IAP也先看不明白。<br>三、编程思路<br>HAL库与正点原子的编程思路给了我很多启示 。看梁晓旭率代码也给了我很多启示 。尽量不要一行一行看代码，哪个变量或地址不懂可以直接全局搜索。这样很容易捋清调用关系。用宏定义多个变量，用分号隔开。建立四个缓冲区的循环buffer和乒乓buffer结合在一起。和加入阈值的处理。<br>四、外设。<br>现在调试过得外设有SDRAM，NOR flash，SD卡，摄像头、RTC时钟、分段式内存管理、FATFS文件系统。<br>五、UCOS操作系统<br>主要是学会建立任务，发信号量与互斥信号量、发送消息队列，事件标志组。<br>六LWIP<br>使用network框架可以像linux那样的TCP框架实现数据的收发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天将STM32的正点原子的历程调了一遍，收获还真不少，为了方便自己理解，现在从接口，编程思路，ARM结构，外设，LWIP，UCOSIII几部分进行一下总结。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="chips" scheme="http://yoursite.com/tags/chips/"/>
    
  </entry>
  
  <entry>
    <title>nanoPi配置AP热点</title>
    <link href="http://yoursite.com/2019/04/03/nanoPi%E9%85%8D%E7%BD%AEAP%E7%83%AD%E7%82%B9/"/>
    <id>http://yoursite.com/2019/04/03/nanoPi配置AP热点/</id>
    <published>2019-04-03T05:18:45.000Z</published>
    <updated>2019-04-03T06:05:41.820Z</updated>
    
    <content type="html"><![CDATA[<p>在nanoPi上移植friendly-core的Ubuntu裁剪版操作系统，并通过iw,ip管理网络，<br>通过hostapd搭建AP热点，通过dhcpd动态自动分配子网。<br><a id="more"></a><br>一、AP是无线访问接入点，可以是WiFi，可以是蓝牙，可以将无线网络客户端连接到一起，然后将无线网络连接到以太网。hostapd可以将无线网卡切换成AP/master模式的守护进程。DHCP服务是根据mac地址自动分配ip的进程。DNS服务器是将域名与ip地址建立在数据库的主机。<br>二、配置AP接入点时要确保没有任何一个应用程序占用无线网卡。包括WSP进程。<br>三、nanaopi通过pppoe连接以太网，需要输入用户名与密码。<br>详见网址：<br><a href="https://www.cnblogs.com/ssooking/p/8571749.html" target="_blank" rel="noopener">https://www.cnblogs.com/ssooking/p/8571749.html</a><br>需要注意的是在输入username是要把横向上的字符串清0<br>四、busybox的作用和功能以及在arm版上安装<a href="https://blog.csdn.net/cy_weiyi/article/details/46953233" target="_blank" rel="noopener">https://blog.csdn.net/cy_weiyi/article/details/46953233</a><br>待补充。</p><p>五、管理网络的工具ip，iw，rfkill<br>1、rfkill用于对系统的无线设备进行打开关闭查找<br>sudo rfkill list :列出所有无线设备<br>sudo rfkill block 0  关闭第0个无线设备<br>ip a<br>ip addr add 192.168.1.199 dev eth0<br>ip link set eth0 up/down<br>iw 启动WIFI连接。<br><a href="https://www.blackmoreops.com/2014/09/18/connect-to-wifi-network-from-command-line-in-linux/" target="_blank" rel="noopener">https://www.blackmoreops.com/2014/09/18/connect-to-wifi-network-from-command-line-in-linux/</a><br>sudo -s 进入root目录<br>service networking restart<br>server isc-dhcp-server restart<br>文件 /etc/network/interface 修改动态ip和静态ip,改完之后重启networking服务<br>文件 /etc/hostapd/hostapd.config<br>文件 /etc/dhcp/dhcpd.config<br>rfkill unblock wlan 启动wlan<br>rfkill block wlan wlan<br>ifup wlan 修改配置文件之后的启动网卡。从静态ip到动态ip<br>hostapd /etc/hostapd/hostapd.config<br>dhcpd</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在nanoPi上移植friendly-core的Ubuntu裁剪版操作系统，并通过iw,ip管理网络，&lt;br&gt;通过hostapd搭建AP热点，通过dhcpd动态自动分配子网。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="ways" scheme="http://yoursite.com/tags/ways/"/>
    
  </entry>
  
  <entry>
    <title>编译连接原理</title>
    <link href="http://yoursite.com/2019/04/03/%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/03/编译连接原理/</id>
    <published>2019-04-03T04:51:05.000Z</published>
    <updated>2019-04-04T01:29:03.027Z</updated>
    
    <content type="html"><![CDATA[<p>讲述c语言从.c和.h文件中产生可执行文件的过程，不同变量的存放位置<br>指定链接库的指令。<br><a id="more"></a><br>1、C语言的编译连接原理—-2018/7/4<br>编辑器：编写代码的窗口<br>编译器：检查代码的语法错误，并将其编译成汇编代码<br>汇编器：将编译出的汇编文件编译成一定功能的目标代码。<br>连接器：将目标代码连接成可执行文件。<br>C语言编译原理：<br>c源程序——预编译处理——编译，优化处理——汇编程序——连接程序——可执行文件。<br>预处理：</p><p>#define 宏定义展开<br>条件编译指令：#if/#endif等</p><p>#include<br>处理注释等特殊符号<br>添加行号和文件标识，输出编译错误警告输出行号。</p><p>#pragma被保留，<br>使用gcc -E可以只进行预编译。<br>编译<br>把预编译的文件进行一系列语法分析生成相应的汇编代码。<br>使用gcc -S 生成编译后的汇编代码<br>汇编：汇编器将汇编代码转换成机器可以执行的命令，每一个汇编指令几乎都对应一条机器指令。根据汇编指令与机器指令的对照表一一翻译即可。<br>执行汇编的指令：gcc -c<br>连接：程序运行需要一多个目标文件，以及所依赖的其他库文件。最后生成可执行文件。连接的目的是将各个模块相互引用的部分处理好。<br>静态连接：在编译阶段将静态库加入到可执行文件中去。相当于复制静态链接库。<br>         -l静态库名（是艾欧）<br>动态连接：连接只需要一些描述信息，而程序执行时在从系统中把相应的动态库加载到内存中。linux动态链接库: .so<br>windows动态连接库 .dll<br>2、C语言的编译连接原理—-2018/7/16<br>预编译会把偷吻键全部复制过去，在编译时会保留使用的将要使用的函数，并编译成汇编文件。<br>今天主要针对多个.c ”重定义“问题进行了思考，对于多个.c与.h文件，虽然有预编译指令#ifndef，但是只对单独的.c文件有过滤性，每个.c文件在预编译时都会复制一份.h中的内容。也就是说，一个.c文件包含了多个.h文件，这些.h文件又相互包含，此时#ifndef才起作用。</p><p>备注：将多个静态库打包成一个静态库的方法：<br>问题：<br>    我有多个静态连接库比如A.a,B.a,C.a，并且我并不知道A B C三个库<br>    由那些文件编译而来，现在我想把他们编译成一个库。</p><p>解答：<br>    .a 文件的结构和.tar文件就没有什么区别。 x 命令解出来， a 命令添加， t命令列表</p><pre><code>楼主的要求只需要，假设A.a, B.a C.a 在/usr/local/lib目录下mkdir /tmp/libABCcd /tmp/libABCar x /usr/local/lib/A.aar x /usr/local/lib/B.aar x /usr/local/lib/C.aar cru libABC.a *.oranlib libABC.a</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述c语言从.c和.h文件中产生可执行文件的过程，不同变量的存放位置&lt;br&gt;指定链接库的指令。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
</feed>
