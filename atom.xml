<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dreamer</title>
  
  <subtitle>莫厌追欢笑语频，寻思离乱好伤神。闲来屈指从头数，得见清平有几人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-19T06:08:54.097Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>梦的蓝天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>散列表</title>
    <link href="http://yoursite.com/2019/04/19/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/19/散列表/</id>
    <published>2019-04-19T01:42:32.000Z</published>
    <updated>2019-04-19T06:08:54.097Z</updated>
    
    <content type="html"><![CDATA[<p>讲解散列表的<br><a id="more"></a><br>散列表最适合的求解问题是查找与给定值相等的记录，不适合做范围查找，不适合进行排序和求最大最小值。<br>同义词：如果两个关键字的散列函数值相等，称两个关键字为同义词。<br>散列函数构造方法：<br>线性函数<br>抽取：从关键字中抽取一部分作为散列位置的方法。比如以电话号码电话号码的最后四位。<br>折叠法：<br>余数法：<br>随机数法：<br>处理散列冲突的方法：<br>1、开放定址法：fi(key)=(f(key)+di)%m   (di=1,2,3,4,5…m-1)  这里的di从1开始依次增加。<br>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。<br>沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）<br>为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到<br>开放的地址则表明表中无待查的关键字，即查找失败。<br>2、在散列函数：事先准备多个散列函数。<br>3、连地址法：将所有关键字为同义词的记录存储在单链表中，在散列表中只存储链表的头结点。<br>4、公共溢出区：把所有冲突的关键词找一个公共溢出区。适用于同义词较少的情况。</p><p>代码实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY 65536</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;HashTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;elem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            H-&gt;elem[i] = NULLKEY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash function,the function can be changeable</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[addr] != NULLKEY)        <span class="comment">//open addressing</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;</span><br><span class="line">    H-&gt;elem[addr] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchHash</span><span class="params">(HashTable *H,<span class="keyword">int</span> key,<span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[*addr] != key)</span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;elem[*addr] == NULLKEY || *addr == Hash(key))</span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    InitHashTable(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> elem[<span class="number">12</span>] = &#123;<span class="number">12</span>,<span class="number">67</span>,<span class="number">56</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">37</span>,<span class="number">22</span>,<span class="number">29</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">34</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        InsertHash(h,elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h-&gt;elem[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SearchHash(h,h-&gt;elem[i],&amp;addr) == SUCCESS)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,addr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"not find\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解散列表的&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://yoursite.com/2019/04/18/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/18/平衡二叉树/</id>
    <published>2019-04-18T13:16:40.000Z</published>
    <updated>2019-04-19T01:16:26.005Z</updated>
    
    <content type="html"><![CDATA[<p>讲解平衡二叉树的定义，相关术语，<br><a id="more"></a><br>定义：是一种平衡二叉树，其中每个节点的左子树和右子树的高度差不大于1.<br>相关术语：<br>平衡因子：二叉树上节点的左子树的高度减去右子树的高度的差值称为平衡因子。<br>最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树。<br>左旋：右孩子的左结点，如果右孩子存在左结点，需要先把他调整为根结点的右结点，然后再追加右孩子的左结点。<br>右旋：左孩子的右结点，如果左孩子存在右结点，需要先把他调整成根节点的左结点，然后再追加左孩子的右结点。<br>构建思想：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因为插入而破坏了树的平衡性，若是，则找出最小不平衡子树，进行相应的旋转，使之成为新的平衡子树。<br>          对于最小不平衡子树根结点BF与它子树的BF符号相反时，说明子树现在的结构与要旋转方向不一至，必须先调整子树结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲解平衡二叉树的定义，相关术语，&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="pragrom" scheme="http://yoursite.com/categories/pragrom/"/>
    
    
  </entry>
  
  <entry>
    <title>freeBSD学习笔记</title>
    <link href="http://yoursite.com/2019/04/18/freeBSD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/18/freeBSD学习笔记/</id>
    <published>2019-04-18T07:44:12.000Z</published>
    <updated>2019-04-18T08:25:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>Linux各种混乱 不堪的发行版相比，FreeBSD只有唯一的版本，同时，FreeBSD关注的是操作系统的稳定性、性能和品质，适合作为服务器的操作系统。<br><a id="more"></a><br>三个主流的linux发行版：Red Hat、Mandrake和SUSE。每一个Linux发行版本都存在一些差异，而它们之间最大的差异则在于文件系统的结构。</p><p>FreeBSD使用“包”来安装、卸载和升级应用程序。‘pkg_add’命令被用于安装一个你手工下载到计算机的包。你也可以用‘-r’开关来让 它自动的从<br>Internet获取，当然，也包括这个包所依赖的一切。FreeBSD包的真正美妙之处在于“连接点”(Ports)树。连接点树是 ——FreeBSD包含的应用程序<br>之间的继承关系。每一个文件夹都包含Makefile，以及让特定应用程序能够在FreeBSD上正确运行所需要的补丁。例如，如果我想安装<br>Apache web服务器，我所需要做的只是cd到/usr/ports/www/apache文件夹，然后运行‘make &amp;&amp; make install’，然后去小吃售卖机前。<br>如果我拥有一台速度够快的电脑，同时拥有一个足够大方的Internet连接，当我回来的时候Apache源代码 的下载、补丁、编译和安装<br>肯定都已经做完了。连接点树也能够处理Apache运行依赖的那些程序，无论我用连接点树安装、手工编译，还是通过安装已经编译<br>好的二进制包。连接点树能够通过$PATH找到它需要的东西。<br>Linux和FreeBSD的另一个区别在于，对于FreeBSD而言，你安装的连接点或者包99%都会被放到/usr/local，而在 Linux上有时是/usr，<br>有时是/opt。这可能只是一个很小的区别，但你至少可以知道你的程序安装到了/usr/local，而不是扩散到了文件系 统的各个地方。</p><p>FreeBSD系统使用cvsup来保持它是最新的。一旦你建立了‘sup-file’，cvsup将会把你本地的系统和cvsup服务器上的进行比较，并且下载那些修改过的东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux各种混乱 不堪的发行版相比，FreeBSD只有唯一的版本，同时，FreeBSD关注的是操作系统的稳定性、性能和品质，适合作为服务器的操作系统。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="freeBSD" scheme="http://yoursite.com/categories/freeBSD/"/>
    
    
  </entry>
  
  <entry>
    <title>sed指令</title>
    <link href="http://yoursite.com/2019/04/17/sed%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/17/sed指令/</id>
    <published>2019-04-17T04:26:54.000Z</published>
    <updated>2019-04-17T04:31:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题来源于怎样通过shell指令查找、替换多个文件中的某字符串<br><a id="more"></a><br>vim在编译模式下进行多文件查找与替换</p><p>替换<br>在一个文件中在vim的编辑模式下这样替换：<br>:25,52s/addr/abcdefg/cg     #将文件中addr替换成abcdefg，c：每次替换会询问，g：全部替换<br>sed指令介绍<br>sed指令把处理的行存入临时缓冲区中，接着用sed指令处理缓冲区的内容，处理完之后把缓冲区的内容送到屏幕<br>但是文件中的内容并没有改变，如果想改变文件中的内容，可以用参数i<br>格式：<br>1、sed [options] ‘指令’ files<br>2、sed [options] -f 脚本 files<br>其中’指令’处可以是正则表达式，正则表达式用/…/分隔<br>替换：<br>1、sed ’s/book/books/‘ files         # s 替换<br>2、sed -n ‘s/book/books/p’ files     # -n -p 结合只用于输出改变的行<br>3、sed ‘s/book/books/g’    files     # g：全部替换<br>4、sed ’s/book/books/ng’   files     # 从n处开始替换<br>5、sed -i ‘s/book/books/g’  files    # 直接编辑文本<br>6、sed -i ‘s/$/abcdefh/g’ files      # 每行的末尾加入abcdefh<br>删除：<br>删除空白行：sed -i ‘/^$/d’ files<br>删除第n行： sed -i ‘/4/d’ files<br>指定删除范围： sed -i ‘2,$/d’ files<br>删除最后一行： sed -i ‘$/d’ files<br>删除文件所有以test开头的行：sed ‘/^test/d’ files</p><p>多个sed组合<br>sed ‘表达式’ | sed ‘表达式’</p><p>-e选项，允许在同一条指令中执行多条语句<br>例如：sed -e ‘1,5d’ -e ‘s/test/abcdef/g’ files<br>第一条语句会对第二条造成影响</p><p>选定行的范围<br>sed -n ‘/test/,/check/p’ files<br>例如：sed -n ‘/5,/^test/p’ files<br>w:写入文件指令(这条指令完全可以用重定向解决)<br>sed -n ‘/test/w file’ example     # 在example中所有包含test的行都被写入到file中，且file被清空</p><p>a\命令 行后添加一行<br>sed ‘/return/this is a line’ client.cpp    # 在client.cpp中包含return的行后面添加this is a line<br>i\命令 行前添加<br>sed ‘/2i\’this is a line’ client.cpp</p><p>注意：<br>1、sed默认使用单引号来引用，但是表达式内部包含变量字符串是，需要用双引号<br>    test=hello<br>    echo hello WORLD | sed “s/$test/HELLO</p><p>awk指令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个问题来源于怎样通过shell指令查找、替换多个文件中的某字符串&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>int,size_t,ssize_t的区别</title>
    <link href="http://yoursite.com/2019/04/11/int-size-t-ssize-t%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/04/11/int-size-t-ssize-t的区别/</id>
    <published>2019-04-11T15:27:22.000Z</published>
    <updated>2019-04-11T16:07:57.248Z</updated>
    
    <content type="html"><![CDATA[<p>讲述int,size_t,ssize_t的区别<br><a id="more"></a><br>科普一下：<br>    32位机器与64位机器是指通用寄存器的长度，代表一次可以处理的数据长度，并不是地址总线的数量。<br>    32位机器，内存空间为4G，所以地址总线最少为32位<br>    64位机器，地址总线一般在40位左右。<br>    地址总线过多，内存位数过多，处理起来很麻烦。</p><p>一、int<br>    int在32位与64位机器上都是32位。32位的大小范围是[-2^31~2^31] 大约等于[-10^9~10^9)<br>二、size_t<br>    size_t这个类型足以表示这台机器上的任何数据的大小。并且一定是unsigned类型。<br>    对于32位机器，size_t是unsigned int，<br>    对于64位机器，size_t是unsigned long 或 unsigned long long<br>三、ssize_t<br>    ssize_t与size_t一样，这个类型足以表示这台机器上的任何数据的大小，只是这个类型一定是signed类型。<br>    对于32位机器，size_t是signed int，<br>    对于64位机器，size_t是signed long 或 signed long long </p><p>下面看一段官方解释<br>&lt;%codeblock%&gt;<br>     This’s a way of defining size_t and ssize_t in Linux:</p><pre><code> //&quot;linux/types.h&quot; typedef __kernel_size_t size_t; typedef __kernel_ssize_t ssize_t; //&quot;asm/posix_types.h&quot;typedef unsigned int __kernel_size_t; typedef int __kernel_ssize_t; It seems so tricky to me. What benefits do we get from such a tricky typedef ? better name (size_t is shorter than unsigned int) ?[/color]On some 64-bit platforms, &apos;int&apos; and &apos;unsigned int&apos; may be 32-bits,while addresses and even memory sizes could require 64 bits(e.g. for the size of an allocated memory block &gt; 4GB).On such platforms, size_t could be typedef&apos;d to a differenttype, such as &apos;unsigned long long&apos;.Note also that &apos;size_t&apos; is a typedef required by the ISO C standard(it must be available if &lt;stddef.h&gt; is included). However, &apos;ssize_t&apos;does not exist in the C standard -- the standard &apos;ptrdiff_t&apos;typedef is nearly equivalent.</code></pre><p>&lt;%endcodeblock%&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述int,size_t,ssize_t的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>工厂类</title>
    <link href="http://yoursite.com/2019/04/08/%E5%B7%A5%E5%8E%82%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/04/08/工厂类/</id>
    <published>2019-04-08T14:37:49.000Z</published>
    <updated>2019-04-08T14:42:28.616Z</updated>
    
    <content type="html"><![CDATA[<p>讲述设计模式之简单工厂类<br><a id="more"></a><br>工厂模式：<br>    简单工厂模式可以理解为负责生产对象的一个类，称为”工厂类”<br>模式原理：<br>![模式组成(工厂类/模式组成.png)]<br>使用步骤：<br>    创建抽象产品类 &amp; 定义具体产品的公共接口；<br>    创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>    创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；<br>    外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例</p><p>使用例子：<br>背景：小成有一个塑料生产厂，用来做塑料加工生意<br>目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">步骤<span class="number">1</span>：创建抽象产品类：</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    public <span class="keyword">abstract</span> void <span class="type">Show</span>();</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">2</span>：创建具体产品类(继承抽象产品类)，定义生产的具体产品</span><br><span class="line"><span class="comment">//具体产品类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductA</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductB</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductC</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void <span class="type">Show</span>() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"生产出了产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">3</span>：创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类实例。</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    public static <span class="type">Product</span> <span class="type">Manufacture</span>(<span class="type">String</span> <span class="type">ProductName</span>)&#123;</span><br><span class="line"><span class="comment">//工厂类里用switch语句控制生产哪种商品；</span></span><br><span class="line"><span class="comment">//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。</span></span><br><span class="line">        switch (<span class="type">ProductName</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductA</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductB</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductC</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">步骤<span class="number">4</span>：外部调用工厂类</span><br><span class="line"><span class="comment">//工厂产品生产流程</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryPattern</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">Factory</span> mFactory = <span class="keyword">new</span> <span class="type">Factory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//调用工厂类的静态方法 &amp; 传入不同参数从而创建产品实例</span></span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"A"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"B"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品C</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"C"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品D</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.<span class="type">Manufacture</span>(<span class="string">"D"</span>).<span class="type">Show</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="type">NullPointerException</span> e)&#123;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述设计模式之简单工厂类&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>linux服务器开发常用四条指令</title>
    <link href="http://yoursite.com/2019/04/06/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%9B%9B%E6%9D%A1%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/06/linux服务器开发常用四条指令/</id>
    <published>2019-04-06T15:38:19.000Z</published>
    <updated>2019-04-06T15:39:55.518Z</updated>
    
    <content type="html"><![CDATA[<p>讲述linux服务器开发4条指令<br><a id="more"></a><br>一、ipcs指令-提供进程间通信方式的信息<br>    ipcs -a 列出所有进程间通信方式的信息<br>    ipcs -m 列出共享内存信息<br>    ipcs -q 列出消息队列信息<br>    ipcs -s 列出信号量信息<br>    ipcs -t 列出更改时间<br>    ipcs -c 列出IPC方式的创建者和拥有者<br>    ipcs -c 列出ipc各种方式的在该系统下的限制条件信息<br>二、ipcrm指令-移除一个消息对象。或者共享内存段，或者一个信号集<br>    参数是由规律的：接大写/小写 M,Q,S代表移除的类型。大写代表按照key值移除。小写代表按照id移除。<br>    例如：ipcrm -M shnkey值 # 移除键值为shnkey的共享内存<br>三、netstat指令：用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。<br>    -a (all)显示所有选项，默认不显示LISTEN相关<br>    -t (tcp)仅显示tcp相关选项<br>    -u (udp)仅显示udp相关选项<br>    -n 拒绝显示别名，能显示数字的全部转化成数字。<br>    -l 仅列出有在 Listen (监听) 的服務状态<br>    -p 显示建立相关链接的程序名<br>    -r 显示路由信息，路由表<br>    -e 显示扩展信息，例如uid等<br>    -s 按各个协议进行统计<br>    -c 每隔一个固定时间，执行该netstat命令。<br>    指令组合举例：<br>    netstat -nat | grep “192.168.1.15:22” |awk ‘{print $5}’|awk -F: ‘{print $1}’|sort|uniq -c|sort -nr|head -20<br>四、tcpdump指令:  tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述linux服务器开发4条指令&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>子网掩码与网关</title>
    <link href="http://yoursite.com/2019/04/05/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%B8%8E%E7%BD%91%E5%85%B3/"/>
    <id>http://yoursite.com/2019/04/05/子网掩码与网关/</id>
    <published>2019-04-05T12:35:19.000Z</published>
    <updated>2019-04-05T12:38:50.546Z</updated>
    
    <content type="html"><![CDATA[<p>以下我们就来深入浅出地讲解什么是子网掩码。<br><a id="more"></a><br>一、IP地址的结构<br>    要想理解什么是子网掩码，就不能不了解IP地址的构成。互联网是由许多小型网络构成的，每个网络上都有许多主机，<br>    这样便构成了一个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络号和主机号两部分，<br>    以便于IP地址的寻址操作。IP地址的网络号和主机号各是多少位呢？如果不指定，就不知道哪些位是网络号、哪些是主机号，<br>    这就需要通过子网掩码来实现。<br>    对于这样的结构ip/1-32，代表子网掩码中网络号的长度<br>    192.168.1.1/24，网络号长度为24</p><p>二、什么是子网掩码<br>    子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。<br>    子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。</p><p>三、三类IP地址<br>    划分A,B,C三类子网的方式是根据IP地址的第一段信息<br>    A类IP地址：1-126<br>    B类IP地址：128-191<br>    C类IP地址：192-155</p><p>四、网络地址与广播地址<br>    网络地址：IP地址与子网掩码&amp;的结果<br>    广播地址：下一个网段的网络地址-1</p><p>五、网关地址<br>    要实现两个子网之间的通信，必须使用网关。比如A网络向B网络发送数据。A网络的主机发现目的主机不在本局域网内，<br>    就将数据发送到自己的网关，再转发到B网络的网关，再有B网络的网关B发送到次局域网中的目的主机。</p><p>再根据CCNA中会出现的题目给大家举个例子：<br>首先，我们看一个考试中常见的题型：一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址。<br>常规办法是把这个主机地址和子网掩码都换算成二进制数，两者进行逻辑与运算后即可得到网络地址。<br>其实大家只要仔细想想，可以得到另一个方法：255.255.255.224的掩码所容纳的IP地址有256－224＝32个（包括网络地址和广播地址），<br>那么具有这种掩码的网络地址一定是32的倍数。而网络地址是子网IP地址的开始，广播地址是结束，可使用的主机地址在这个范围内，<br>因此略小于137而又是32的倍数的只有128，所以得出网络地址是202.112.14.128。而广播地址就是下一个网络的网络地址减1。而下一个32的倍数是160，<br>因此可以得到广播地址为202.112.14.159。</p><p>子网络 2进制子网络域数 2进制主机域数的范围 2进制主机域数的范围<br>第1个子网络 000 00000 thru 11111 .0 thru.31<br>第2个子网络 001 00000 thru 11111 .32 thru.63<br>第3个子网络 010 00000 thru 11111 .64 thru.95<br>第4个子网络 011 00000 thru 11111 .96 thru.127<br>第5个子网络 100 00000 thru 11111 .128 thru.159<br>第6个子网络 101 00000 thru 11111 .160 thru.191<br>第7个子网络 110 00000 thru 11111 .192 thru.223<br>第8个子网络 111 00000 thru 11111 .124 thru.255 </p><p>CCNA考试中，还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。比如一个子网有10台主机，那么对于这个子网需要的IP地址是：<br>10＋1＋1＋1＝13<br>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。因为13小于16（16等于2的4次方），所以主机位为4位。而<br>256－16＝240<br>所以该子网掩码为255.255.255.240。<br>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为：<br>14＋1＋1＋1＝17<br>17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下我们就来深入浅出地讲解什么是子网掩码。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>shell指令</title>
    <link href="http://yoursite.com/2019/04/04/shell%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/04/shell指令/</id>
    <published>2019-04-04T14:50:28.000Z</published>
    <updated>2019-04-04T14:55:04.963Z</updated>
    
    <content type="html"><![CDATA[<p>讲述shell编程中的常用命令：apt<br><a id="more"></a><br>一、apt指令<br>    apt-cache search # ——(package 搜索包)<br>    apt-cache show #——(package 获取包的相关信息，如说明、大小、版本等)<br>    sudo apt-get install # ——(package 安装包)sudo apt-get install # —–(package - - reinstall 重新安装包)<br>    sudo apt-get -f install # —–(强制安装?#”-f = –fix-missing”当是修复安装吧…)<br>    sudo apt-get remove #—–(package 删除包)<br>    sudo apt-get remove - - purge # ——(package 删除包，包括删除配置文件等)<br>    sudo apt-get autoremove –purge # —-(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)<br>    sudo apt-get update #——更新源<br>    sudo apt-get upgrade #——更新已安装的包<br>    sudo apt-get dist-upgrade # ———升级系统<br>    sudo apt-get dselect-upgrade #——使用 dselect 升级<br>    apt-cache depends #——-(package 了解使用依赖)<br>    apt-cache rdepends # ——(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧…)<br>    sudo apt-get build-dep # ——(package 安装相关的编译环境)<br>    apt-get source #——(package 下载该包的源代码)<br>    sudo apt-get clean &amp;&amp; sudo apt-get autoclean # ——–清理下载文件的存档 &amp;&amp; 只清理过时的包<br>    sudo apt-get check #——-检查是否有损坏的依赖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述shell编程中的常用命令：apt&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>51单片机RAM与ROM</title>
    <link href="http://yoursite.com/2019/04/04/51%E5%8D%95%E7%89%87%E6%9C%BARAM%E4%B8%8EROM/"/>
    <id>http://yoursite.com/2019/04/04/51单片机RAM与ROM/</id>
    <published>2019-04-04T00:33:42.000Z</published>
    <updated>2019-04-04T01:26:15.823Z</updated>
    
    <content type="html"><![CDATA[<p>讲述51单片机的内存分配形式，进而想清楚单片机程序执行的流程。<br><a id="more"></a><br>51单片机在物理结构上有4个存储空间：<br>1、片内数据存储器<br>2、片外数据存储器<br>3、片内程序存储器<br>4、片外程序存储器<br>对于用户而言，只有三个，片内外统一寻址的程序存储器(MOVC),片内数据存储器(MOV),片外数据存储器(MOVX).<br>51单片机支持64kROM和64kRAM</p><p>程序存储器：<br>    4kROM在片内，此时EA置1即可。再使用片外ROM时，需要将EA接地，POSN接片外ROM的片选信号。当=1时，程序从片内ROM开始执行，当PC值超过片内ROM容量时会自动转向外部ROM空间。<br>    ROM存储结构是：<br>    0000H —— 系统复位，PC指向此处；<br>    0003H —— 外部中断0入口<br>    000BH —— T0溢出中断入口<br>    0013H —— 外中断1入口<br>    001BH —— T1溢出中断入口<br>    0023H —— 串口中断入口<br>    002BH —— T2溢出中断入口<br>    0033H —— 用户ROM<br>    <img src="/2019/04/04/51单片机RAM与ROM/ROM结构.png" alt="ROM结构"><br>数据存取器(RAM)：<br>    物理上分为两大区：00H ~ 7FH即128B内RAM 和 SFR区。<br>    <img src="/2019/04/04/51单片机RAM与ROM/片内RAM.png" alt="片内RAM"><br>51单片机支持的寻址方式：<br>    立即数寻址：立即数寻址又称立即寻址，即指令中直接给出操作数的寻址方式称为立即数寻址。在51系列单片机指令系统中，立即数用前面加“#”号的8位数表示（#data，如#30H）或16位数（#data16，如#2052H）表示。举例说明立即数寻址方式，以传送指令为例。<br>    例：MOV A, #80H ；80H——&gt;A<br>    MOV DPTR, #2000H ；2000H——&gt;DPTR<br>    直接寻址：指令中直接给出操作数地址（dir）的寻址方式称为直接寻址。寻址对象为：1 内部数据存储器，在指令中以直接地址表示；2特殊功能寄存器SFR，在指令中用寄存器名称表示。<br>    例：MOV A, 25H ；内部RAM的（25H）——&gt;A<br>    MOV P0, #45H ；45H——&gt;P0 ,P0为直接寻址的SFR<br>    MOV 30H，20H ；内部RAM的（20H）——&gt;（30H）<br>    寄存器寻址：以通用寄存器的内容为操作数的寻址方式称为寄存器寻址。通用寄存器包括：A、B、DPTR、R0～R7。其中B寄存器仅在乘法、除法指令中为寄存器寻址，在其它指令中为直接寻址。A寄存器可以寄存器寻址，又可以直接寻址（此时写作ACC）。直接寻址和寄存器寻址的差别在于，直接寻址是操作数所在的字节地址（占一个字节），寄存器寻址是寄存器编码出现在指令码中。寄存器寻址速度比直接寻址要快。除上面所指的几个寄存器外，其它特殊功能寄存器一律为直接寻址。<br>    例：MOV A, R0 ；R0——&gt;A，R0为寄存器寻址<br>    MUL AB ；A×B——&gt;BA，A，B为寄存器寻址<br>    MOV B, R0 ；R0——&gt;B，R0为寄存器寻址，B为直接寻址<br>    PUSH ACC ；A的内容入栈，A为直接寻址<br>    ADD A, ACC ；A为寄存器寻址，ACC为直接寻址<br>    寄存器间接寻址：以寄存器中的内容为地址，该地址的内容为操作数的寻址方式称为寄存器间接寻址。能够进行寄存器间接寻址的寄存器有：R0、R1、DPTR，用前面加@表示，如@R0、@R1、@DPTR。寄存器间接寻址的存储空间包括内部数据存储器和外部数据存储器。由于内部数据存储器共有128字节，因此用一字节的R0和R1可间接寻址整个空间。而外部数据存储器最大可达64K，仅R0或R1无法寻址整个空间，为此需要由P2端口提供外部RAM高8位地址，由R0或R1提供低8位地址，由此共同寻址64K字节范围。也可用16位的DPTR寄存器间接寻址64K字节存储空间。在指令中，是对内部RAM还是对外部RAM寻址，区别在于对外部RAM的操作仅有数据传送指令，并且用MOVX作为操作助记符。<br>    例：MOV @R0, A ；A——&gt;以R0内容为地址的内部RAM中<br>    MOVX @DPTR, A ；A——&gt;以DPTR内容为地址的外部RAM中<br>    变址寻址：由寄存器DPTR或PC中的内容加上A累加器内容之和而形成操作数地址的寻址方式称为变址寻址。变址寻址只能对程序存储器中的数据进行寻址操作。由于程序存储器是只读存贮器，因此变址寻址只有读操作而无写操作。在指令符号上采用MOVC的形式。<br>    例：MOVC A, @A+DPTR ；（A+DPTR）——&gt;A<br>    MOVC A, @A+PC ； （PC）+1——PC （（A）+（PC））——&gt;A<br>    位寻址：对位地址中的内容进行位操作的寻址方式称为位寻址。由于单片机中只有内部RAM和特殊功能寄存器的部分单元有位地址，因此位寻址只能对有位地址的这两个空间进行寻址操作。位寻址是一种直接寻址方式，由指令给出直接位地址。与直接寻址不同的是，位寻址只给出位地址，而不是字节地址。<br>    例：SETB 20H ；1——&gt;20H位<br>    MOV 32H, C ；进位Cy（即指令中的C）——&gt;32H位<br>    相对寻址：以当前程序计数器PC的内容为基址，加上指令给出的一字节补码数（偏移量）形成新的PC值的寻址方式称为相对寻址。相对寻址方式只修改PC值，故主要用于实现程序的分支转移。<br>    例：SJMP 08H ；PC+2+08H——&gt;PC （该指令为两字节，所以有PC+2）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述51单片机的内存分配形式，进而想清楚单片机程序执行的流程。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="chips" scheme="http://yoursite.com/tags/chips/"/>
    
  </entry>
  
  <entry>
    <title>滑动串口、OOD数据</title>
    <link href="http://yoursite.com/2019/04/03/%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/04/03/协议/</id>
    <published>2019-04-03T05:47:13.000Z</published>
    <updated>2019-04-17T04:36:41.192Z</updated>
    
    <content type="html"><![CDATA[<p>记录TCP滑动窗口，带外数据和缓冲区<br><a id="more"></a><br>一、带外数据：OOB数据是是传输协议层使用的out of data(带外数据)，来发送一些重要数据。一般不使用与数据相同的通道，而是使用特殊的通道，使得数据不容易被阻塞。TCP协议没有所谓的带外数据，而是使用一种紧急模式：设置URG位为1。在程序中，接受OOB数据将recv中的flag为设置成MSG_OOB（windows），发送OOB数据将send的flag设置成MSG_OOB即可。      </p><p>二、缓冲区<br><img src="/2019/04/03/协议/缓冲区.png" alt="缓冲区"><br>当没有调用recv时，内核接受缓冲区的数据一致存在。<br>由于TCP发送完数据之后需要应答ACK，一致等待应答很浪费时间，此时需要滑动窗口。<br>三、滑动窗口<br><img src="/2019/04/03/协议/滑动窗口1.png" alt="滑动窗口1"><br>在窗口内的数据：#2，#3。已经发送但还未应答的数据段32-45.TCP会分成四段发送出去：s1,s2,s3,s4。如果已经收到s1，s2，s4但未收到s3。此时接受端发送应答。此时窗口会右移到s3处。为了保证传输顺序。此时TCP等待一段时间之后会重传（重传机制），重传成功后，s3,s4被遗弃确认。不成功s4被丢弃。<br>流量控制：<br>超时重传机制：见上面。<br>累计ACK：TCP并不是对被一个报文段都会ACK，可能会两个报文一起ACK。<br><img src="/2019/04/03/协议/滑动窗口2.png" alt="滑动窗口2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录TCP滑动窗口，带外数据和缓冲区&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>C语言DLL文件产生和调用</title>
    <link href="http://yoursite.com/2019/04/03/C%E8%AF%AD%E8%A8%80DLL%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E5%92%8C%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/03/C语言DLL文件产生和调用/</id>
    <published>2019-04-03T05:33:33.000Z</published>
    <updated>2019-04-04T00:44:09.645Z</updated>
    
    <content type="html"><![CDATA[<p>讲述C/C++产生的DLL文件怎样被C++或C#调用<br><a id="more"></a><br>创建DLL文件，选择win32项目，选择生成DLL<br><img src="/2019/04/03/C语言DLL文件产生和调用/创建.png" alt="创建"><br>添加头文件和.c文件<br>头文件中的声明<br><img src="/2019/04/03/C语言DLL文件产生和调用/声明.png" alt="声明"><br>.c文件中可以定义中间函数，这个中间函数可一直任何普通函数。然后导出函数一定要加<br>_stdcall 并且导出函数一定是要在头文件中用_declsped声明的。<br><img src="/2019/04/03/C语言DLL文件产生和调用/导出.png" alt="导出"><br>3.添加模块文件.def。<br>4.点击生成解决方案就产生了DLL。</p><p>二、C#调用DLL的方法<br>  包含运行时库<br>using System.Runtime.InteropServices;//运行时库<br>将DLL拷贝到根目录<br>导出语法如下：<br><img src="/2019/04/03/C语言DLL文件产生和调用/Csharp导入.png" alt="Csharp导入"><br>4.Area就是一个在C#中直接调用的成员方法。<br>详细网址<br><a href="https://blog.csdn.net/C_xxy/article/details/78998758" target="_blank" rel="noopener">https://blog.csdn.net/C_xxy/article/details/78998758</a></p><p>三、C++调用DLL的方法<br>1、加载DLL库<br>    HINSTANCE hinstLib = LoadLibrary(TEXT(“ytr.dll”));<br>2、声明函数指针<br>    typedef int (__stdcall *MYPROC)(LPWSTR,LPWSTR);<br>    MYPROC ProcAdd;<br>3、函数指针赋值<br>    ProcAdd = (MYPROC)GetProcAddress(hinstLib,”FB_Open”);<br>4、函数指针调用函数<br>    ProcAdd(3,”abc”)    //两个参数的函数指针调用过程<br>5、释放DLL<br>    BOOL fFreeResult = FreeLibrary(hinstLib);<br>用VS查看DLL是多少位的，这里需要注意64为的应用程序不能调用32 为DLL，32 为应用程序也不能调用64为DLL。<br><img src="/2019/04/03/C语言DLL文件产生和调用/查看.png" alt="查看"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述C/C++产生的DLL文件怎样被C++或C#调用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="program" scheme="http://yoursite.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>再读STM32笔记</title>
    <link href="http://yoursite.com/2019/04/03/%E5%86%8D%E8%AF%BBSTM32%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/03/再读STM32笔记/</id>
    <published>2019-04-03T05:25:24.000Z</published>
    <updated>2019-04-03T06:05:39.620Z</updated>
    
    <content type="html"><![CDATA[<p>这些天将STM32的正点原子的历程调了一遍，收获还真不少，为了方便自己理解，现在从接口，编程思路，ARM结构，外设，LWIP，UCOSIII几部分进行一下总结。<br><a id="more"></a><br>一、接口，先了解的接口有：<br>SCCB–DCMI—数字摄像头接口<br>SAI—串行音频接口<br>SDIO—安全数字输入输出接口<br>LTCD—RGB显示屏接口<br>FMC—扩展外部RAM接口<br>二、ARM结构<br>cotexM4CPU的共分7个block，每个block=512M。block3、4、5、6为FMC连接的外部存储器。block0包含flash memory=1M为用户程序存储器。64k的CCMRAM。block1包含还包含192k的SRAM。block2为APB1,2与AHB1,2连接的外设。这些外设当然就是那些接口。cotexM4采用总线矩阵的形式管理取址，取数据，执行的过程。<br><img src="/2019/04/03/再读STM32笔记/总线结构.png" alt="总线结构"><br>由于这种单片机的功能太多，一个引脚对应一种功能太浪费资源。出现了重映射与复用。重映射也就是说一个外设可能对应多种引脚，比如UART0_RX可以和4个引脚对应，这是就可以用重映射到其他引脚。复用就是用来一个引脚的第二三功能。开启复用功能时不需要把一个外设的所有引都打开，只需要打开一个引脚的复用功能就好。<br><img src="/2019/04/03/再读STM32笔记/引脚复用.png" alt="引脚复用"><br>在线升级应用程序IAP<br><img src="/2019/04/03/再读STM32笔记/IAP.png" alt="IAP"><br>中断管理这里先不说，在线升级IAP也先看不明白。<br>三、编程思路<br>HAL库与正点原子的编程思路给了我很多启示 。看梁晓旭率代码也给了我很多启示 。尽量不要一行一行看代码，哪个变量或地址不懂可以直接全局搜索。这样很容易捋清调用关系。用宏定义多个变量，用分号隔开。建立四个缓冲区的循环buffer和乒乓buffer结合在一起。和加入阈值的处理。<br>四、外设。<br>现在调试过得外设有SDRAM，NOR flash，SD卡，摄像头、RTC时钟、分段式内存管理、FATFS文件系统。<br>五、UCOS操作系统<br>主要是学会建立任务，发信号量与互斥信号量、发送消息队列，事件标志组。<br>六LWIP<br>使用network框架可以像linux那样的TCP框架实现数据的收发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天将STM32的正点原子的历程调了一遍，收获还真不少，为了方便自己理解，现在从接口，编程思路，ARM结构，外设，LWIP，UCOSIII几部分进行一下总结。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="chips" scheme="http://yoursite.com/tags/chips/"/>
    
  </entry>
  
  <entry>
    <title>nanoPi配置AP热点</title>
    <link href="http://yoursite.com/2019/04/03/nanoPi%E9%85%8D%E7%BD%AEAP%E7%83%AD%E7%82%B9/"/>
    <id>http://yoursite.com/2019/04/03/nanoPi配置AP热点/</id>
    <published>2019-04-03T05:18:45.000Z</published>
    <updated>2019-04-03T06:05:41.820Z</updated>
    
    <content type="html"><![CDATA[<p>在nanoPi上移植friendly-core的Ubuntu裁剪版操作系统，并通过iw,ip管理网络，<br>通过hostapd搭建AP热点，通过dhcpd动态自动分配子网。<br><a id="more"></a><br>一、AP是无线访问接入点，可以是WiFi，可以是蓝牙，可以将无线网络客户端连接到一起，然后将无线网络连接到以太网。hostapd可以将无线网卡切换成AP/master模式的守护进程。DHCP服务是根据mac地址自动分配ip的进程。DNS服务器是将域名与ip地址建立在数据库的主机。<br>二、配置AP接入点时要确保没有任何一个应用程序占用无线网卡。包括WSP进程。<br>三、nanaopi通过pppoe连接以太网，需要输入用户名与密码。<br>详见网址：<br><a href="https://www.cnblogs.com/ssooking/p/8571749.html" target="_blank" rel="noopener">https://www.cnblogs.com/ssooking/p/8571749.html</a><br>需要注意的是在输入username是要把横向上的字符串清0<br>四、busybox的作用和功能以及在arm版上安装<a href="https://blog.csdn.net/cy_weiyi/article/details/46953233" target="_blank" rel="noopener">https://blog.csdn.net/cy_weiyi/article/details/46953233</a><br>待补充。</p><p>五、管理网络的工具ip，iw，rfkill<br>1、rfkill用于对系统的无线设备进行打开关闭查找<br>sudo rfkill list :列出所有无线设备<br>sudo rfkill block 0  关闭第0个无线设备<br>ip a<br>ip addr add 192.168.1.199 dev eth0<br>ip link set eth0 up/down<br>iw 启动WIFI连接。<br><a href="https://www.blackmoreops.com/2014/09/18/connect-to-wifi-network-from-command-line-in-linux/" target="_blank" rel="noopener">https://www.blackmoreops.com/2014/09/18/connect-to-wifi-network-from-command-line-in-linux/</a><br>sudo -s 进入root目录<br>service networking restart<br>server isc-dhcp-server restart<br>文件 /etc/network/interface 修改动态ip和静态ip,改完之后重启networking服务<br>文件 /etc/hostapd/hostapd.config<br>文件 /etc/dhcp/dhcpd.config<br>rfkill unblock wlan 启动wlan<br>rfkill block wlan wlan<br>ifup wlan 修改配置文件之后的启动网卡。从静态ip到动态ip<br>hostapd /etc/hostapd/hostapd.config<br>dhcpd</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在nanoPi上移植friendly-core的Ubuntu裁剪版操作系统，并通过iw,ip管理网络，&lt;br&gt;通过hostapd搭建AP热点，通过dhcpd动态自动分配子网。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="ways" scheme="http://yoursite.com/tags/ways/"/>
    
  </entry>
  
  <entry>
    <title>编译连接原理</title>
    <link href="http://yoursite.com/2019/04/03/%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/03/编译连接原理/</id>
    <published>2019-04-03T04:51:05.000Z</published>
    <updated>2019-04-04T01:29:03.027Z</updated>
    
    <content type="html"><![CDATA[<p>讲述c语言从.c和.h文件中产生可执行文件的过程，不同变量的存放位置<br>指定链接库的指令。<br><a id="more"></a><br>1、C语言的编译连接原理—-2018/7/4<br>编辑器：编写代码的窗口<br>编译器：检查代码的语法错误，并将其编译成汇编代码<br>汇编器：将编译出的汇编文件编译成一定功能的目标代码。<br>连接器：将目标代码连接成可执行文件。<br>C语言编译原理：<br>c源程序——预编译处理——编译，优化处理——汇编程序——连接程序——可执行文件。<br>预处理：</p><p>#define 宏定义展开<br>条件编译指令：#if/#endif等</p><p>#include<br>处理注释等特殊符号<br>添加行号和文件标识，输出编译错误警告输出行号。</p><p>#pragma被保留，<br>使用gcc -E可以只进行预编译。<br>编译<br>把预编译的文件进行一系列语法分析生成相应的汇编代码。<br>使用gcc -S 生成编译后的汇编代码<br>汇编：汇编器将汇编代码转换成机器可以执行的命令，每一个汇编指令几乎都对应一条机器指令。根据汇编指令与机器指令的对照表一一翻译即可。<br>执行汇编的指令：gcc -c<br>连接：程序运行需要一多个目标文件，以及所依赖的其他库文件。最后生成可执行文件。连接的目的是将各个模块相互引用的部分处理好。<br>静态连接：在编译阶段将静态库加入到可执行文件中去。相当于复制静态链接库。<br>         -l静态库名（是艾欧）<br>动态连接：连接只需要一些描述信息，而程序执行时在从系统中把相应的动态库加载到内存中。linux动态链接库: .so<br>windows动态连接库 .dll<br>2、C语言的编译连接原理—-2018/7/16<br>预编译会把偷吻键全部复制过去，在编译时会保留使用的将要使用的函数，并编译成汇编文件。<br>今天主要针对多个.c ”重定义“问题进行了思考，对于多个.c与.h文件，虽然有预编译指令#ifndef，但是只对单独的.c文件有过滤性，每个.c文件在预编译时都会复制一份.h中的内容。也就是说，一个.c文件包含了多个.h文件，这些.h文件又相互包含，此时#ifndef才起作用。</p><p>备注：将多个静态库打包成一个静态库的方法：<br>问题：<br>    我有多个静态连接库比如A.a,B.a,C.a，并且我并不知道A B C三个库<br>    由那些文件编译而来，现在我想把他们编译成一个库。</p><p>解答：<br>    .a 文件的结构和.tar文件就没有什么区别。 x 命令解出来， a 命令添加， t命令列表</p><pre><code>楼主的要求只需要，假设A.a, B.a C.a 在/usr/local/lib目录下mkdir /tmp/libABCcd /tmp/libABCar x /usr/local/lib/A.aar x /usr/local/lib/B.aar x /usr/local/lib/C.aar cru libABC.a *.oranlib libABC.a</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述c语言从.c和.h文件中产生可执行文件的过程，不同变量的存放位置&lt;br&gt;指定链接库的指令。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>linux并发API</title>
    <link href="http://yoursite.com/2019/04/03/linux%E5%B9%B6%E5%8F%91API/"/>
    <id>http://yoursite.com/2019/04/03/linux并发API/</id>
    <published>2019-04-03T04:43:57.000Z</published>
    <updated>2019-04-03T04:49:34.202Z</updated>
    
    <content type="html"><![CDATA[<p>总结linux中posix 和system V 中相关的多线程与多进程中的API函数，包括：<br>线程创建，设置线程属性，互斥锁，读写锁，条件变量，屏障，信号量，消息队列，共享内存<br><a id="more"></a><br>1、int pthread_attr_init(pthread_attr_t <em>attr)<br>   int pthread_attr_destory(pthread_attr_t </em>attr)</p><p>2、int pthread_equal(pthread_t th1,pthread_t th2)   // 比较两个线程id<br>    pthread_self(void)                                 // 获取自身线程id</p><p>3、int pthread_create(pthread_t tidp,pthread_attr_t <em>restrict attr,void </em>(<em>start_rtn(void </em>)),void <em>arg)   //每个线程提供一个errno副本<br>4、线程退出方式：（1）简单返回：return n<br>                   （2）被同一进程中的其他线程取消<br>                   （3）pthread_exit(void </em>rval_ptr)<br>5、void pthread_join(pthread_t thread,void *<em> rval_ptr) //阻塞等待指定线程退出<br>6、int pthread_cancel(pthread_t tid) //请求同一进程中的其他线程非正常退出<br>7、void pthread_cleanup_push(void (</em>rtn)(void <em>),void </em>arg)    //线程退出时回调函数，将函数依次放到栈中<br>   void pthread_cleanup_pop(int execute);                        //1.清理回调函数 2.execute非0时调用回调函数<br>   //线程执行以下动作时，回调函数才会触发：<br>   (1)调用pthread_exit()<br>   (2)用非0execute调用pthread_cleanup_pop<br>   (3)响应请求取消</p><p>8、int pthread_detach(pthread_t tid)  //将结合态的线程变成分离态的线程<br>9、int pthread_mutex_init(pthread_mutex_t <em>restrict mutex,const pthread_mutexattr_t </em>restrict attr);<br>    int pthread_mutex_destroy(pthread_mutex_t <em>);<br>    int pthread_mutex_lock(pthread_mutex_t </em>);<br>    int pthread_mutex_unlock(pthread_mutex_t <em>);<br>    int pthread_mutex_trylock(pthread_mutex_t </em>);  //如果互斥锁已经被锁住，返回一个错误状态。<br>10、int pthread_mutex_timedlock();<br>11、int pthread_rwlock_init(pthread_rwlock_t <em>restrict attr,const pthread_rwlockattr_t </em>restrict attr) //初始化读写锁<br>    int pthread_rwlock_destory(pthread_rwlock_t <em>rwlock)<br>    int pthread_rwlock_rdlock(pthread_rwlock_t </em>);<br>    int pthread_rwlock_wrlock(pthread_rwlock_t <em>);<br>    int pthread_rwlock_unlock(pthread_rwlock_t </em>);<br>12、pthread_cond_init(pthread_cond_t <em>reatrict cond,const pthread_condattr_t </em>restrict attr);           //初始化条件变量<br>    int pthread_cond_destory(pthread_cond_t <em>);<br>    int pthread_cond_wait(pthread_cond_t </em>restrict cond,pthread_mutex_t *restrict mutex);</p><p>13、int pthread_barrier_init();                            //屏障，同步多个线程，参数省略<br>    int pthread_barrier_destory();<br>    int pthread_barrier_wait(pthread_barrier_t *)      // 屏障等待多个线程</p><p>14、//内存映射(进程)<br>    void<em> mmap(void </em>addr,size_t len,int port,int flags,int fd,off_t offset)  //将文件映射成内存<br>    int munmap(void <em>addr,size_t len)                                            //解除映射，共享内存中的内容写入文件<br>    int msync(void </em>addr,size_t len,int flags)                                  //保证共享内存与文件的内容一致<br>    //XSI共享存储<br>    int shmget(key_t key,size_t size,int flags)                                 //创建或得到共享内存，返回shmid<br>    void <em>shmat(int shmid,const void </em>addr,int flags)                          //将shmget得到的共享内存映射到进程的地址空间，返回被映射的地址<br>    int shmdt(void *addr);                                                       //解除映射</p><p>15、//消息队列<br>    int msgget(key_t key,int msgflag);                                            //IPC_PRIVATE:创建消息队列<br>    int msgctl(key_t key,int cmd,struct msqid_ds<em> buf)                          //设置<br>    ssize_t msgsnd(int msgid,const void</em> msgp,size_t msgsz,int flag)           //消息写入队列  flag常设置成IPC_NOWAIT，空/满不阻塞<br>    int msgrcv(int msgid,const void* msgp,size_t msgsz,int flag)                //从队列中取消息    msgp指向消息的类型，接下来是消息信息</p><pre><code>//用户定义的通用结构：struct msgstru{    long mtype;                    //大于0，消息类型    char mtext[512];                //消息内容};</code></pre><p>16、//system V信号量<br>    int semget(key_t key,int nsems,int semflg)                                  //创建，成功返回信号量的id<br>    int semop(int semid,struct sembuf *sops,unsigned nsops)                    //执行信号量集合上的操作数组，PV操作函数<br>    int semctl(int semid,int semnum,int cmd,union semun arg)                   //实现对信号量的各种控制操作，初始化，删除等</p><pre><code>//POSIX信号量int sem_init(sem_t *sem.int pshared,unsigned value)                        //初始化信号量int sem_wait(sem_t *)                                                         //阻塞当前线程直到sem大于0int sem_post(sem_t *)                                                         //信号量的值加1intsem_destory(sem_t *)                                                       //释放信号量</code></pre><p>17、//条件变量<br>    int pthread_cond_init(pthread_cond_t <em>cond,pthread_condattr_t </em>attr)      //动态初始化条件变量，静态初始化PTHREAD_COND_INITIALIZER<br>    int pthread_cond_wait(pthread_cond_t <em>cond,pthread_mutex_lock </em>lock)      //等待条件变量发信号，同时释放互斥锁<br>    int pthread_cond_signal(pthread_cond_t <em>cond)                                // 只能使一个等待的条件变量编程非阻塞，若有多个条件变量处于等待状态，会按照线程优先级选择<br>    int pthread_cond_broadsignal(pthread_cond_t </em>cond)                          //</p><pre><code>//xxxctl常用命令字IPC_STAT  //取东西IPC_SRT   //设置东西IPC_RMID  //删除</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结linux中posix 和system V 中相关的多线程与多进程中的API函数，包括：&lt;br&gt;线程创建，设置线程属性，互斥锁，读写锁，条件变量，屏障，信号量，消息队列，共享内存&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>python笔记</title>
    <link href="http://yoursite.com/2019/04/02/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/02/python笔记/</id>
    <published>2019-04-02T05:16:00.000Z</published>
    <updated>2019-04-03T05:36:02.138Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记<br><a id="more"></a></p><p>一、dict使用<br>    1、创建{}<br>    2、使用dict()将含有双值子序列的序列转化成字典<br>    3、使用update()合并两个字典，若有重复则替换<br>    4、使用del删除指定key的字典<br>    5、使用clear()或指向一个{}清空dict<br>    6、使用in判断键值是否在字典中<br>    7、使用keys()获取所有键。使用values获取所有值<br>    8、使用items获取所有键值对，每一个键值对用tuple形式存储，整体用list存储<br>二、tuple使用<br>    1、创建， </p><p>三、函数<br>    1、yield 创建迭代器函数使用的关键字，每一次迭代遇到yield就返回其后的值，下一次迭代从此处(函数处)开始。<br>        def my_range(first=0,last=5,step=1):<br>            number = first<br>            while number &lt; last:<br>                yield number<br>                number += step</p><p>四、类<br>    1、self 指向这个被创建的对象本身<br>    2、对象调用成员函数做的两件事：<br>        a、找到对象所属的类<br>        b、将对象传递给成员函数的self参数<br>    3、super()方法<br>    4、属性 name=property(get,set)<br>    5、名称重整：<strong>name<br>    6、@classmethod 类方法，@staticmethod 静态方法<br>    7、iterator和iteratable：重要的两个方法：</strong>iter__()：返回迭代器本身<br>                                             <strong>next</strong>():返回当前值<br>                                                       :改变iterator状态<br>    8、generator 只要包含<strong>iter</strong>()和<strong>next</strong>()即可，但直接用yield也可以。有两种使用方式：next()和send()<br>    9、特殊方法，其实就是运算符重载<br>五、@abstractmethod方法<br>    python中的接口必须借助ABC模块使用–from abc import AECMeta,abstarctmethod<br>    @abstractmethod<br>    def 方法名():</p><pre><code>@abstractmethod方法必须被子类重载。带@abstractmethod的方法不能实例化        </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>vim学习笔记(一)</title>
    <link href="http://yoursite.com/2019/04/02/vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/04/02/vim学习笔记一/</id>
    <published>2019-04-02T02:31:56.000Z</published>
    <updated>2019-04-15T17:21:25.377Z</updated>
    
    <content type="html"><![CDATA[<p>常用vim指令<br><a id="more"></a><br>撤销：u<br>复制和粘贴：在退出编辑后。v+移动光标+y(复制)+p(粘贴)  –yump(复制)，put(放置)<br>批量缩进：  在退出编辑后。:24,26&gt;  –右移，:24,26&lt; –左移<br>修改指令别名：<br>    以下是一种改完之后永久生效的方法<br>    1、在用户的家目录找到.bashrc,vim ~/.bashrc<br>    2、在.bashrc中添加修改别名语句：alias wmysql=’mysql -u root -pxidianicelab313’，保存退出<br>    3、在终端使.bashrc生效（不用重启）：source ~/.bashrc</p><p>备注：source指令：使当前shell读入文件路径并以此执行文件中的指令，用于执行刚修改的初始化文件。</p><p>查看内存:free -m(m为MB，g为GB)<br>                  total        used        free      shared  buff/cache   available<br>    Mem:           3933        1193         358          32        2382        2372<br>    Swap:          4093           9        4084</p><p>查看磁盘:df -lh<br>    Filesystem      Size  Used Avail Use% Mounted on<br>    udev            2.0G     0  2.0G   0% /dev<br>    tmpfs           394M   27M  368M   7% /run<br>    /dev/sda1        16G   14G  1.1G  93% /<br>    tmpfs           2.0G  248K  2.0G   1% /dev/shm<br>    tmpfs           5.0M  4.0K  5.0M   1% /run/lock<br>    tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup<br>    vmhgfs-fuse     292G  156G  137G  54% /mnt/hgfs<br>    cgmfs           100K     0  100K   0% /run/cgmanager/fs<br>    tmpfs           394M   88K  394M   1% /run/user/1000<br>CPU使用：cat /proc/cpuinfo</p><p>查看某个用户可以打开的文件描述符 ulimit -a<br>修改打开的文件描述符<br>临时修改：ulimit -n 20000   (只对当前用户有效)<br>永久修改：vim /etc/security/limits.conf<br>加入：    * soft nofile 4096</p><pre><code>* hard nofile 4096* 代表所有用户，可以根据某个用户修改fdipzone soft nofile 8192fdipzone hard nofile 8192</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用vim指令&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>51单片机扩展RAM与ROM</title>
    <link href="http://yoursite.com/2019/03/04/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%89%A9%E5%B1%95RAM%E4%B8%8EROM/"/>
    <id>http://yoursite.com/2019/03/04/51单片机扩展RAM与ROM/</id>
    <published>2019-03-04T05:05:58.000Z</published>
    <updated>2019-04-05T02:22:58.006Z</updated>
    
    <content type="html"><![CDATA[<p>讲述51单片机扩展片外RAM和ROM的方式<br><a id="more"></a><br>一、最小系统<br>  片内带程序存储器的8051本身即可构成一片最小系统，只需接上时钟电路和复位电路即可。<br>  同时EA接高电平，ALE和PSEN不接，系统即可工作。<br>  <img src="/2019/03/04/51单片机扩展RAM与ROM/最小系统.png" alt="最小系统"><br>二、单片机的三总线结构<br>  数据总线：P0口<br>  地址总线：带地址锁存的P2口和不带地址锁存的P0口<br>  控制总线：PSEN、WR、RD组成<br>  单片机的P0口的读写周期中，前半周期输出地址，单片机自动将ALE输出高电平，后半周期输出数据，ALE为低电平<br>  所以，可以用ALE接地址锁存器的锁存端。<br>  <img src="/2019/03/04/51单片机扩展RAM与ROM/P0分时复用.png" alt="P0分时复用"><br>三、系统扩展连线图<br>  在这里不谈线选法和译码法，只提供一种包含系统扩展原理的原理图。<br>  <img src="/2019/03/04/51单片机扩展RAM与ROM/扩展.png" alt="扩展"><br>  对于扩展芯片多于1片时可以考虑加译码器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述51单片机扩展片外RAM和ROM的方式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="chips" scheme="http://yoursite.com/tags/chips/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://yoursite.com/2019/02/03/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/03/二叉排序树/</id>
    <published>2019-02-03T14:53:58.000Z</published>
    <updated>2019-04-03T15:13:50.157Z</updated>
    
    <content type="html"><![CDATA[<p>讲述二叉排序树的插入，查找，删除操作<br><a id="more"></a><br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define TRUE 1</span></span><br><span class="line"><span class="comment">#define FALSE 0</span></span><br><span class="line"></span><br><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    struct BiTNode *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SearchBST(BiTree T,<span class="keyword">int</span> key,BiTree f,BiTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild,key,T,p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild,key,T,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> InsertBST(BiTree *T,<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree s;</span><br><span class="line">    BiTree p = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">    <span class="keyword">if</span>(SearchBST(*T,key,<span class="keyword">NULL</span>,&amp;p) == <span class="keyword">FALSE</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lchild=s-&gt;rchild=<span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">NULL</span>)      <span class="comment">//haven't root node</span></span><br><span class="line">            *T = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p-&gt;data)</span><br><span class="line">            p-&gt;lchild = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; p-&gt;data)</span><br><span class="line">            p-&gt;rchild = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Delete(BiTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line">    BiTree q,s;</span><br><span class="line">    d=(*p)-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((*p)-&gt;rchild == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;</span><br><span class="line">        free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild == <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;</span><br><span class="line">        free(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        s=(*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q!=*p)</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        free(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DeleteBST(BiTree *T,<span class="keyword">int</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*T == <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == (*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt;(*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">62</span>,<span class="number">88</span>,<span class="number">58</span>,<span class="number">73</span>,<span class="number">99</span>,<span class="number">93</span>,<span class="number">41</span>,<span class="number">51</span>,<span class="number">35</span>,<span class="number">37</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    BiTree *T = (BiTree *)malloc(sizeof(BiTNode));</span><br><span class="line">    BiTree f;</span><br><span class="line">    BiTree *p = (BiTree *)malloc(sizeof(BiTNode));</span><br><span class="line">    <span class="comment">//create a Binary Tree</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">        InsertBST(T,arr[i]);</span><br><span class="line">    <span class="keyword">int</span> d = DeleteBST(T,<span class="number">88</span>);</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：这里特别强调主函数中传递的实参T，必须用malloc申请内存，应为InsertBST中使用了指针*T。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述二叉排序树的插入，查找，删除操作&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
