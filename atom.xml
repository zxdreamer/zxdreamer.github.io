<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dreamer</title>
  
  <subtitle>莫厌追欢笑语频，寻思离乱好伤神。闲来屈指从头数，得见清平有几人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-18T08:25:41.642Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>梦的蓝天</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>freeBSD学习笔记</title>
    <link href="http://yoursite.com/2019/04/18/freeBSD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/18/freeBSD学习笔记/</id>
    <published>2019-04-18T07:44:12.000Z</published>
    <updated>2019-04-18T08:25:41.642Z</updated>
    
    <content type="html"><![CDATA[<p>Linux各种混乱 不堪的发行版相比，FreeBSD只有唯一的版本，同时，FreeBSD关注的是操作系统的稳定性、性能和品质，适合作为服务器的操作系统。<br><a id="more"></a><br>三个主流的linux发行版：Red Hat、Mandrake和SUSE。每一个Linux发行版本都存在一些差异，而它们之间最大的差异则在于文件系统的结构。</p><p>FreeBSD使用“包”来安装、卸载和升级应用程序。‘pkg_add’命令被用于安装一个你手工下载到计算机的包。你也可以用‘-r’开关来让 它自动的从<br>Internet获取，当然，也包括这个包所依赖的一切。FreeBSD包的真正美妙之处在于“连接点”(Ports)树。连接点树是 ——FreeBSD包含的应用程序<br>之间的继承关系。每一个文件夹都包含Makefile，以及让特定应用程序能够在FreeBSD上正确运行所需要的补丁。例如，如果我想安装<br>Apache web服务器，我所需要做的只是cd到/usr/ports/www/apache文件夹，然后运行‘make &amp;&amp; make install’，然后去小吃售卖机前。<br>如果我拥有一台速度够快的电脑，同时拥有一个足够大方的Internet连接，当我回来的时候Apache源代码 的下载、补丁、编译和安装<br>肯定都已经做完了。连接点树也能够处理Apache运行依赖的那些程序，无论我用连接点树安装、手工编译，还是通过安装已经编译<br>好的二进制包。连接点树能够通过$PATH找到它需要的东西。<br>Linux和FreeBSD的另一个区别在于，对于FreeBSD而言，你安装的连接点或者包99%都会被放到/usr/local，而在 Linux上有时是/usr，<br>有时是/opt。这可能只是一个很小的区别，但你至少可以知道你的程序安装到了/usr/local，而不是扩散到了文件系 统的各个地方。</p><p>FreeBSD系统使用cvsup来保持它是最新的。一旦你建立了‘sup-file’，cvsup将会把你本地的系统和cvsup服务器上的进行比较，并且下载那些修改过的东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux各种混乱 不堪的发行版相比，FreeBSD只有唯一的版本，同时，FreeBSD关注的是操作系统的稳定性、性能和品质，适合作为服务器的操作系统。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="freeBSD" scheme="http://yoursite.com/categories/freeBSD/"/>
    
    
  </entry>
  
  <entry>
    <title>sed指令</title>
    <link href="http://yoursite.com/2019/04/17/sed%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/17/sed指令/</id>
    <published>2019-04-17T04:26:54.000Z</published>
    <updated>2019-04-17T04:31:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题来源于怎样通过shell指令查找、替换多个文件中的某字符串<br><a id="more"></a><br>vim在编译模式下进行多文件查找与替换</p><p>替换<br>在一个文件中在vim的编辑模式下这样替换：<br>:25,52s/addr/abcdefg/cg     #将文件中addr替换成abcdefg，c：每次替换会询问，g：全部替换<br>sed指令介绍<br>sed指令把处理的行存入临时缓冲区中，接着用sed指令处理缓冲区的内容，处理完之后把缓冲区的内容送到屏幕<br>但是文件中的内容并没有改变，如果想改变文件中的内容，可以用参数i<br>格式：<br>1、sed [options] ‘指令’ files<br>2、sed [options] -f 脚本 files<br>其中’指令’处可以是正则表达式，正则表达式用/…/分隔<br>替换：<br>1、sed ’s/book/books/‘ files         # s 替换<br>2、sed -n ‘s/book/books/p’ files     # -n -p 结合只用于输出改变的行<br>3、sed ‘s/book/books/g’    files     # g：全部替换<br>4、sed ’s/book/books/ng’   files     # 从n处开始替换<br>5、sed -i ‘s/book/books/g’  files    # 直接编辑文本<br>6、sed -i ‘s/$/abcdefh/g’ files      # 每行的末尾加入abcdefh<br>删除：<br>删除空白行：sed -i ‘/^$/d’ files<br>删除第n行： sed -i ‘/4/d’ files<br>指定删除范围： sed -i ‘2,$/d’ files<br>删除最后一行： sed -i ‘$/d’ files<br>删除文件所有以test开头的行：sed ‘/^test/d’ files</p><p>多个sed组合<br>sed ‘表达式’ | sed ‘表达式’</p><p>-e选项，允许在同一条指令中执行多条语句<br>例如：sed -e ‘1,5d’ -e ‘s/test/abcdef/g’ files<br>第一条语句会对第二条造成影响</p><p>选定行的范围<br>sed -n ‘/test/,/check/p’ files<br>例如：sed -n ‘/5,/^test/p’ files<br>w:写入文件指令(这条指令完全可以用重定向解决)<br>sed -n ‘/test/w file’ example     # 在example中所有包含test的行都被写入到file中，且file被清空</p><p>a\命令 行后添加一行<br>sed ‘/return/this is a line’ client.cpp    # 在client.cpp中包含return的行后面添加this is a line<br>i\命令 行前添加<br>sed ‘/2i\’this is a line’ client.cpp</p><p>注意：<br>1、sed默认使用单引号来引用，但是表达式内部包含变量字符串是，需要用双引号<br>    test=hello<br>    echo hello WORLD | sed “s/$test/HELLO</p><p>awk指令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个问题来源于怎样通过shell指令查找、替换多个文件中的某字符串&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="operate" scheme="http://yoursite.com/tags/operate/"/>
    
  </entry>
  
  <entry>
    <title>51单片机RAM与ROM</title>
    <link href="http://yoursite.com/2019/04/04/51%E5%8D%95%E7%89%87%E6%9C%BARAM%E4%B8%8EROM/"/>
    <id>http://yoursite.com/2019/04/04/51单片机RAM与ROM/</id>
    <published>2019-04-04T00:33:42.000Z</published>
    <updated>2019-04-04T01:26:15.823Z</updated>
    
    <content type="html"><![CDATA[<p>讲述51单片机的内存分配形式，进而想清楚单片机程序执行的流程。<br><a id="more"></a><br>51单片机在物理结构上有4个存储空间：<br>1、片内数据存储器<br>2、片外数据存储器<br>3、片内程序存储器<br>4、片外程序存储器<br>对于用户而言，只有三个，片内外统一寻址的程序存储器(MOVC),片内数据存储器(MOV),片外数据存储器(MOVX).<br>51单片机支持64kROM和64kRAM</p><p>程序存储器：<br>    4kROM在片内，此时EA置1即可。再使用片外ROM时，需要将EA接地，POSN接片外ROM的片选信号。当=1时，程序从片内ROM开始执行，当PC值超过片内ROM容量时会自动转向外部ROM空间。<br>    ROM存储结构是：<br>    0000H —— 系统复位，PC指向此处；<br>    0003H —— 外部中断0入口<br>    000BH —— T0溢出中断入口<br>    0013H —— 外中断1入口<br>    001BH —— T1溢出中断入口<br>    0023H —— 串口中断入口<br>    002BH —— T2溢出中断入口<br>    0033H —— 用户ROM<br>    <img src="/2019/04/04/51单片机RAM与ROM/ROM结构.png" alt="ROM结构"><br>数据存取器(RAM)：<br>    物理上分为两大区：00H ~ 7FH即128B内RAM 和 SFR区。<br>    <img src="/2019/04/04/51单片机RAM与ROM/片内RAM.png" alt="片内RAM"><br>51单片机支持的寻址方式：<br>    立即数寻址：立即数寻址又称立即寻址，即指令中直接给出操作数的寻址方式称为立即数寻址。在51系列单片机指令系统中，立即数用前面加“#”号的8位数表示（#data，如#30H）或16位数（#data16，如#2052H）表示。举例说明立即数寻址方式，以传送指令为例。<br>    例：MOV A, #80H ；80H——&gt;A<br>    MOV DPTR, #2000H ；2000H——&gt;DPTR<br>    直接寻址：指令中直接给出操作数地址（dir）的寻址方式称为直接寻址。寻址对象为：1 内部数据存储器，在指令中以直接地址表示；2特殊功能寄存器SFR，在指令中用寄存器名称表示。<br>    例：MOV A, 25H ；内部RAM的（25H）——&gt;A<br>    MOV P0, #45H ；45H——&gt;P0 ,P0为直接寻址的SFR<br>    MOV 30H，20H ；内部RAM的（20H）——&gt;（30H）<br>    寄存器寻址：以通用寄存器的内容为操作数的寻址方式称为寄存器寻址。通用寄存器包括：A、B、DPTR、R0～R7。其中B寄存器仅在乘法、除法指令中为寄存器寻址，在其它指令中为直接寻址。A寄存器可以寄存器寻址，又可以直接寻址（此时写作ACC）。直接寻址和寄存器寻址的差别在于，直接寻址是操作数所在的字节地址（占一个字节），寄存器寻址是寄存器编码出现在指令码中。寄存器寻址速度比直接寻址要快。除上面所指的几个寄存器外，其它特殊功能寄存器一律为直接寻址。<br>    例：MOV A, R0 ；R0——&gt;A，R0为寄存器寻址<br>    MUL AB ；A×B——&gt;BA，A，B为寄存器寻址<br>    MOV B, R0 ；R0——&gt;B，R0为寄存器寻址，B为直接寻址<br>    PUSH ACC ；A的内容入栈，A为直接寻址<br>    ADD A, ACC ；A为寄存器寻址，ACC为直接寻址<br>    寄存器间接寻址：以寄存器中的内容为地址，该地址的内容为操作数的寻址方式称为寄存器间接寻址。能够进行寄存器间接寻址的寄存器有：R0、R1、DPTR，用前面加@表示，如@R0、@R1、@DPTR。寄存器间接寻址的存储空间包括内部数据存储器和外部数据存储器。由于内部数据存储器共有128字节，因此用一字节的R0和R1可间接寻址整个空间。而外部数据存储器最大可达64K，仅R0或R1无法寻址整个空间，为此需要由P2端口提供外部RAM高8位地址，由R0或R1提供低8位地址，由此共同寻址64K字节范围。也可用16位的DPTR寄存器间接寻址64K字节存储空间。在指令中，是对内部RAM还是对外部RAM寻址，区别在于对外部RAM的操作仅有数据传送指令，并且用MOVX作为操作助记符。<br>    例：MOV @R0, A ；A——&gt;以R0内容为地址的内部RAM中<br>    MOVX @DPTR, A ；A——&gt;以DPTR内容为地址的外部RAM中<br>    变址寻址：由寄存器DPTR或PC中的内容加上A累加器内容之和而形成操作数地址的寻址方式称为变址寻址。变址寻址只能对程序存储器中的数据进行寻址操作。由于程序存储器是只读存贮器，因此变址寻址只有读操作而无写操作。在指令符号上采用MOVC的形式。<br>    例：MOVC A, @A+DPTR ；（A+DPTR）——&gt;A<br>    MOVC A, @A+PC ； （PC）+1——PC （（A）+（PC））——&gt;A<br>    位寻址：对位地址中的内容进行位操作的寻址方式称为位寻址。由于单片机中只有内部RAM和特殊功能寄存器的部分单元有位地址，因此位寻址只能对有位地址的这两个空间进行寻址操作。位寻址是一种直接寻址方式，由指令给出直接位地址。与直接寻址不同的是，位寻址只给出位地址，而不是字节地址。<br>    例：SETB 20H ；1——&gt;20H位<br>    MOV 32H, C ；进位Cy（即指令中的C）——&gt;32H位<br>    相对寻址：以当前程序计数器PC的内容为基址，加上指令给出的一字节补码数（偏移量）形成新的PC值的寻址方式称为相对寻址。相对寻址方式只修改PC值，故主要用于实现程序的分支转移。<br>    例：SJMP 08H ；PC+2+08H——&gt;PC （该指令为两字节，所以有PC+2）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲述51单片机的内存分配形式，进而想清楚单片机程序执行的流程。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
